{
    "sourceFile": ".environment/gitleaks/run-gitleaks.sh",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1660063825923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1660063825923,
            "name": "Commit-0",
            "content": "#!/usr/bin/env bash\n\nfunction usage() {\n    echo \"usage: ${0} [OPTION]\"\n    echo \"\"\n    echo \"Runs the gitleaks container on top of your code. The default mode (i.e. without any options) scans\"\n    echo \"the files that are staged in git.\"\n    echo \"\"\n    echo \"Options:\"\n    echo \"    --no-git          Scans your current working directory as is (i.e. pretends it isn't a git repo)\"\n    echo \"    --depth <int>     Scans the <int> (topologically) last commits of the repository\"\n    echo \"    --since <datespc> Scans the commits since a date (format: 'YYYY-mm-DD[THH:MM:SS-OFFSET]'\"\n    echo \"    --help|-h         Shows this help and exits successfully\"\n    echo \"\"\n    echo \"Examples:\"\n    echo \"\"\n    echo \"  $ ${0}\"\n    echo \"      Runs gitleaks over the files that are currently marked as staging\"\n    echo \"\"\n    echo \"  $ ${0} --no-git\"\n    echo \"      Runs gitleaks over the current state of the repository\"\n    echo \"\"\n    echo \"  $ ${0} --depth 10\"\n    echo \"      Runs gitleaks on the 10 (topologically) last commits\"\n    echo \"\"\n    echo \"  $ VERBOSE=1 ${0} --since '2021-06-01'\"\n    echo \"      Runs gitleaks on the commits in your repository since June 1st, 2021 while setting the VERBOSE flag\"\n    echo \"\"\n    echo \"\"\n}\n\nfunction error() {\n    echo \"Gitleaks> ERROR: ${*}\"\n}\n\nfunction warning() {\n    echo \"Gitleaks> Warning: ${*}\"\n}\n\nfunction note() {\n    echo \"Gitleaks> info: ${*}\"\n}\n\n# Use a well known, stable version\nGITLEAKS_IMG_NAME=\"zricethezav/gitleaks:v8.10.2\"\nREPO_ROOT=$(git rev-parse --show-toplevel)\nCONTAINER_SOURCE_LOCATION=\"/repo\"\nCONTAINER_LOCATION=\"repo\"\nVERBOSE=${VERBOSE:-0}\nSCRIPT_DIR=\"$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\n\nREPORT_JSON=\"gitleaks.report.json\"\nLOGFILE=\"gitleaks.log\"\n\nREPO_CONFIG_PATH=\".environment/gitleaks/gitleaks-config.toml\"\nCONFIG_FILE=\"gitleaks-config.toml\"\n\n# Run gitleaks locally if installed\nLOCAL_GITLEAKS=0\nif command -v gitleaks &> /dev/null; then\n    LOCAL_GITLEAKS=1\nfi\n\nfunction base_command() {\n    if [[ ${LOCAL_GITLEAKS?} == 1 ]]; then\n        echo \"running gitleaks locally\"\n        gitleaks protect \\\n            --source=\"${REPO_ROOT?}\" \\\n            --report-path=\"${REPO_ROOT?}/${REPORT_JSON?}\" \\\n            --config=\"${SCRIPT_DIR?}/${CONFIG_FILE?}\" \\\n            --report-format \"json\" \\\n            $(if [[ ${VERBOSE?} != 0 ]]; then echo \"--verbose\"; else echo \"\"; fi) \\\n            $1 \n    else\n        echo \"running gitleaks in docker\"\n        docker run \\\n            -v \"${REPO_ROOT?}:${CONTAINER_SOURCE_LOCATION?}\" \\\n            --rm \\\n            \"${GITLEAKS_IMG_NAME?}\" protect \\\n            --source=\"${CONTAINER_SOURCE_LOCATION?}\" \\\n            --report-path=\"${CONTAINER_SOURCE_LOCATION?}/${REPORT_JSON?}\" \\\n            --config=\"${CONTAINER_SOURCE_LOCATION?}/${REPO_CONFIG_PATH?}\" \\\n            --report-format \"json\" \\\n            $(if [[ ${VERBOSE?} != 0 ]]; then echo \"--verbose\"; else echo \"\"; fi) \\\n            $1\n    fi\n    RC=$?\n\n    return ${RC?}\n}\n\nfunction scan_uncommitted() {\n    note \"Scanning your suggested changes.\"\n\n    base_command \"--staged\"\n\n    RC=$?\n\n    return ${RC?}\n}\n\nfunction scan_no_git() {\n    note \"Scanning the current state of the repository.\"\n\n    base_command \"--no-git\"\n\n    RC=$?\n\n    return ${RC?}\n}\n\nfunction scan_x_last_commits() {\n    DEPTH=${1}\n    note \"Scanning the last ${DEPTH?} commits.\"\n\n    base_command \"--depth ${DEPTH?}\"\n\n    RC=$?\n\n    return ${RC?}\n}\n\nfunction scan_since() {\n    SINCE=${1}\n    note \"Scanning all commits since ${SINCE?}.\"\n\n    base_command \"--commit-since \\\"${SINCE?}\\\"\"\n\n    RC=$?\n\n    return ${RC?}\n}\n\n# Parse arguments\nHAS_UNRECOGNIZED=0\n\n# Default type of thing we do\nSELECTED_RUNMODE=\"\"\nRUNMODE_STAGED_UNCOMMITTED=\"uncommitted\"\nRUNMODE_NO_GIT=\"no-git\"\nRUNMODE_DEPTH=\"depth\"\nRUNMODE_DEPTH_VALUE=\"\"\nRUNMODE_SINCE=\"since\"\nRUNMODE_SINCE_VALUE=\"\"\nwhile [[ ! -z \"${1}\" ]]; do\n    case \"${1}\" in\n    \"--${RUNMODE_DEPTH?}\" | \"--${RUNMODE_SINCE?}\")\n        if [[ ! -z \"${SELECTED_RUNMODE?}\" ]]; then\n            warning \"The previously specified run-mode '${SELECTED_RUNMODE?}' will be overridden by the latest run-mode '${1:2}'.\"\n        fi\n        SELECTED_RUNMODE=\"${1:2}\"\n\n        if [[ -z \"${2}\" || \"${2:0:1}\" == \"--\" ]]; then\n            error \"The value for run-mode '${1:2}' is not defined.\"\n            exit 1\n        else\n            case \"${SELECTED_RUNMODE?}\" in\n            \"${RUNMODE_DEPTH?}\")\n                RUNMODE_DEPTH_VALUE=\"${2}\"\n                ;;\n            \"${RUNMODE_SINCE?}\")\n                RUNMODE_SINCE_VALUE=\"${2}\"\n                ;;\n            *)\n                error \"'${SELECTED_RUNMODE}' is not yet handled\"\n                ;;\n            esac\n\n            # We used an extra argument, shift that\n            shift\n        fi\n        ;;\n    \"--${RUNMODE_NO_GIT?}\")\n        if [[ ! -z \"${SELECTED_RUNMODE?}\" ]]; then\n            warning \"The previously specified run-mode '${SELECTED_RUNMODE?}' will be overridden by the latest run-mode '${1:2}'.\"\n        fi\n        SELECTED_RUNMODE=\"${RUNMODE_NO_GIT?}\"\n        ;;\n    \"--help\" | \"-h\")\n        usage\n        exit 0\n        ;;\n    *)\n        # Keep collecting the unrecognized options\n        error \"Option \\\"${1}\\\" is not a recognized option.\"\n        HAS_UNRECOGNIZED=1\n        ;;\n    esac\n\n    shift\ndone\n\n# Exit in error if you provided any invalid option\nif [[ ${HAS_UNRECOGNIZED?} != 0 ]]; then\n    echo \"\"\n    usage\n    exit 1\nfi\n\n# Set default run-mode if none was select\nif [[ -z \"${SELECTED_RUNMODE?}\" ]]; then\n    SELECTED_RUNMODE=\"${RUNMODE_STAGED_UNCOMMITTED?}\"\nfi\n\nRC=1 # Nothing done, fail\ncase \"${SELECTED_RUNMODE?}\" in\n\"${RUNMODE_DEPTH?}\")\n    scan_x_last_commits ${RUNMODE_DEPTH_VALUE?}\n    RC=$?\n    ;;\n\"${RUNMODE_NO_GIT}\")\n    scan_no_git\n    RC=$?\n    ;;\n\"${RUNMODE_SINCE?}\")\n    scan_since \"${RUNMODE_SINCE_VALUE?}\"\n    RC=$?\n    ;;\n\"${RUNMODE_STAGED_UNCOMMITTED?}\")\n    # Default action\n    scan_uncommitted\n    RC=$?\n    ;;\n*)\n    error \"The selected run-mode \\\"${SELECTED_RUNMODE?}\\\" is not a recognized one.\"\n    exit 1\n    ;;\nesac\n\nif [[ ${RC?} != 0 ]]; then\n    error \"(return code=${RC?}) Your code may contain secrets, consult the output above and/or one of the following files for more details:\"\n    error \"     - ${REPO_ROOT?}/${REPORT_JSON?}\"\n    error \"     - ${REPO_ROOT?}/${LOGFILE?}\"\nfi\n\nexit ${RC?}\n"
        }
    ]
}