<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:CompareData.kt$DataCompareTest$!it[ConfigColumns.INPUT_FILE.colName].isNullOrBlank() &amp;&amp; !it[ConfigColumns.SENDER.colName].isNullOrBlank() &amp;&amp; !it[ConfigColumns.RECEIVER_ORG_NAME.colName].isNullOrBlank() &amp;&amp; !it[ConfigColumns.RECEIVER_NAME.colName].isNullOrBlank() &amp;&amp; !it[ConfigColumns.EXPECTED_COUNT.colName].isNullOrBlank()</ID>
    <ID>ComplexCondition:Environment.kt$Environment.Companion$inputUrl.port > 0 &amp;&amp; ( (inputUrl.protocol == "http" &amp;&amp; inputUrl.port != 80) || (inputUrl.protocol == "https" &amp;&amp; inputUrl.port != 443) )</ID>
    <ID>ComplexCondition:Hl7Serializer.kt$Hl7Serializer$blanksForUnknownFields.contains(element.name) &amp;&amp; element.hl7Field != null &amp;&amp; (value.equals("ASKU", true) || value.equals("UNK", true))</ID>
    <ID>ComplexCondition:Hl7Serializer.kt$Hl7Serializer$value.length > HD_TRUNCATION_LIMIT &amp;&amp; element.type == Element.Type.TEXT &amp;&amp; hl7Field in HD_FIELDS_LOCAL &amp;&amp; hl7Config?.truncateHDNamespaceIds == true</ID>
    <ID>ComplexCondition:LookupTableCommands.kt$LookupTableEndpointUtilities.Companion$info.tableName.isNullOrBlank() || info.tableVersion &lt; 1 || info.createdBy.isNullOrBlank() || info.createdBy.isNullOrBlank()</ID>
    <ID>ComplexCondition:ReportFunction.kt$ReportFunction$sender == null || schema == null || content.isEmpty() || errors.isNotEmpty()</ID>
    <ID>ComplexMethod:ActionHistory.kt$ActionHistory$ fun createResponseBody( options: Options, warnings: List&lt;ResultDetail>, errors: List&lt;ResultDetail>, verbose: Boolean, report: Report? = null ): String</ID>
    <ID>ComplexMethod:CheckFunction.kt$CheckFunction$ @FunctionName("check") fun run( @HttpTrigger( name = "check", methods = [HttpMethod.GET, HttpMethod.POST], authLevel = AuthorizationLevel.FUNCTION, ) request: HttpRequestMessage&lt;String?>, ): HttpResponseMessage</ID>
    <ID>ComplexMethod:CompareData.kt$CompareCsvData$ fun compare( expected: InputStream, actual: InputStream, schema: Schema, result: CompareData.Result = CompareData.Result() ): CompareData.Result</ID>
    <ID>ComplexMethod:CompareData.kt$CompareCsvData$ fun compareCsvRow( actualRow: List&lt;String>, expectedRow: List&lt;String>, expectedHeaders: List&lt;String>, schema: Schema, actualRowNum: Int, result: CompareData.Result ): Boolean</ID>
    <ID>ComplexMethod:CompareData.kt$CompareHl7Data$ fun compare( expected: InputStream, actual: InputStream, result: CompareData.Result = CompareData.Result() ): CompareData.Result</ID>
    <ID>ComplexMethod:CsvSerializer.kt$CsvSerializer$ private fun mapRow(schema: Schema, csvMapping: CsvMapping, inputRow: Map&lt;String, String>, index: Int): RowResult</ID>
    <ID>ComplexMethod:CsvSerializer.kt$CsvSerializer$fun readExternal( schemaName: String, input: InputStream, sources: List&lt;Source>, destination: Receiver? = null, defaultValues: Map&lt;String, String> = emptyMap(), ): ReadResult</ID>
    <ID>ComplexMethod:Element.kt$Element$ fun checkForError(formattedValue: String, format: String? = null): ResponseMessage?</ID>
    <ID>ComplexMethod:Element.kt$Element$ fun toFormatted( normalizedValue: String, format: String? = null, ): String</ID>
    <ID>ComplexMethod:Element.kt$Element$ fun toNormalized(formattedValue: String, format: String? = null): String</ID>
    <ID>ComplexMethod:Element.kt$Element$fun inheritFrom(baseElement: Element): Element</ID>
    <ID>ComplexMethod:Element.kt$Element$fun toNormalized(subValues: List&lt;SubValue>): String</ID>
    <ID>ComplexMethod:FakeReport.kt$FakeDataService$fun getFakeValueForElement( element: Element, context: FakeReport.RowContext, ): String</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$ fun convertMessageToMap(message: String, schema: Schema): RowResult</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$ internal fun decodeHl7DateTime( terser: Terser, element: Element, hl7Field: String, warnings: MutableList&lt;String> ): String</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$ internal fun decodeHl7TelecomData(terser: Terser, element: Element, hl7Field: String): String</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$/* * Read in a file */ fun convertBatchMessagesToMap(message: String, schema: Schema): Hl7Mapping</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$private fun buildMessage( message: ORU_R01, report: Report, row: Int, processingId: String = "T", )</ID>
    <ID>ComplexMethod:Hl7Serializer.kt$Hl7Serializer$private fun setComponent( terser: Terser, element: Element, hl7Field: String, value: String, report: Report )</ID>
    <ID>ComplexMethod:LookupTable.kt$LookupTable$ fun lookupBestMatch( searchColumn: String, searchValue: String, lookupColumn: String, canonicalize: (String) -> String, commonWords: List&lt;String> = emptyList(), filterColumn: String? = null, filterValue: String? = null, ): String?</ID>
    <ID>ComplexMethod:LookupTableCommands.kt$LookupTableCreateCommand$override fun run()</ID>
    <ID>ComplexMethod:Mappers.kt$DateTimeOffsetMapper$override fun apply(element: Element, args: List&lt;String>, values: List&lt;ElementAndValue>): String?</ID>
    <ID>ComplexMethod:Mappers.kt$Obx8Mapper$override fun apply(element: Element, args: List&lt;String>, values: List&lt;ElementAndValue>): String?</ID>
    <ID>ComplexMethod:Metadata.kt$Metadata$ private fun fixupElement(element: Element, baseElement: Element? = null): Element</ID>
    <ID>ComplexMethod:ProcessDataCommands.kt$ProcessData$override fun run()</ID>
    <ID>ComplexMethod:RedoxSerializer.kt$RedoxSerializer$private fun writeField(to: JsonGenerator, field: JsonField, value: String)</ID>
    <ID>ComplexMethod:RedoxTransport.kt$RedoxTransport$override fun send( transportType: TransportType, header: WorkflowEngine.Header, sentReportId: ReportId, retryItems: RetryItems?, context: ExecutionContext, actionHistory: ActionHistory, ): RetryItems?</ID>
    <ID>ComplexMethod:Report.kt$Report$ fun getDeidentifiedResultMetaData(): List&lt;CovidResultMetadata></ID>
    <ID>ComplexMethod:Report.kt$Report$ private fun buildColumnPass2( mapping: Translator.Mapping, toElement: Element, pass1Columns: List&lt;StringColumn?> ): StringColumn</ID>
    <ID>ComplexMethod:ReportFunction.kt$ReportFunction$private fun validateRequest(engine: WorkflowEngine, request: HttpRequestMessage&lt;String?>): ValidatedRequest</ID>
    <ID>ComplexMethod:TestReportStream.kt$SantaClaus$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ComplexMethod:WorkflowEngine.kt$WorkflowEngine$ fun resendEvent( reportId: ReportId, receiver: Receiver, sendFailedOnly: Boolean, isTest: Boolean, msgs: MutableList&lt;String>, )</ID>
    <ID>ConstructorParameterNaming:HistoryFunctions.kt$Facility$val CLIA: String?</ID>
    <ID>ConstructorParameterNaming:HistoryFunctions.kt$Facility.Builder$var CLIA: String? = null</ID>
    <ID>EmptyCatchBlock:Element.kt$Element${ }</ID>
    <ID>EmptyCatchBlock:Hl7Serializer.kt$Hl7Serializer${ }</ID>
    <ID>EmptyDefaultConstructor:AuthenticationStrategy.kt$AuthenticationStrategy$()</ID>
    <ID>EmptyDefaultConstructor:CredentialManagement.kt$CredentialHelper$()</ID>
    <ID>EmptyDefaultConstructor:RedoxTransport.kt$RedoxTransport$()</ID>
    <ID>EmptyDefaultConstructor:SecretManagement.kt$SecretHelper$()</ID>
    <ID>EmptyFunctionBlock:CsvSerializerTests.kt$CsvSerializerTests${ }</ID>
    <ID>EmptyFunctionBlock:SettingCommands.kt$MultipleSettings${}</ID>
    <ID>EmptyFunctionBlock:SettingCommands.kt$OrganizationSettings${}</ID>
    <ID>EmptyFunctionBlock:SettingCommands.kt$ReceiverSettings${}</ID>
    <ID>EmptyFunctionBlock:SettingCommands.kt$SenderSettings${}</ID>
    <ID>EnumNaming:Scope.kt$Scope.Companion.DetailedScope.report$report</ID>
    <ID>EqualsWithHashCodeExist:Event.kt$ProcessEvent : Event</ID>
    <ID>EqualsWithHashCodeExist:Event.kt$ReceiverEvent : Event</ID>
    <ID>EqualsWithHashCodeExist:Event.kt$ReportEvent : Event</ID>
    <ID>ForbiddenComment:ActionHistory.kt$ActionHistory$// TODO: need to get the correct path and set the ENDPOINT_BASE correctly, blocked by waiting for</ID>
    <ID>ForbiddenComment:ActionHistory.kt$ActionHistory.Companion$// TODO: Deprecated. Delete. WorkflowEngine.handleRecieverEvent pulls in each report individually.</ID>
    <ID>ForbiddenComment:CsvComparer.kt$CsvComparer$// TODO: should we throw an error if we are adding the same key twice?</ID>
    <ID>ForbiddenComment:FakeReportTests.kt$FakeReportTests$// todo: update for different formats as we expand the offerings for other consumers</ID>
    <ID>ForbiddenComment:FakeReportTests.kt$FakeReportTests$// todo: update when we provide different formats for different consumers</ID>
    <ID>ForbiddenComment:Hl7Serializer.kt$Hl7Serializer$// todo: convert to result detail, maybe</ID>
    <ID>ForbiddenComment:Hl7Serializer.kt$Hl7Serializer$// todo: map each AOE by the AOE question ID</ID>
    <ID>ForbiddenComment:HttpUtilities.kt$HttpUtilities.Companion$* Allows the validator to figure out specific failure, and pass it in here. * Can be used for any response code. * Todo: other generic failure response methods here could be removed, and replaced with this * generic method, instead of having to create a new method for every HttpStatus code.</ID>
    <ID>ForbiddenComment:Mappers.kt$CoalesceMapper$// todo: add the option for a default value</ID>
    <ID>ForbiddenComment:Mappers.kt$UseMapper$// TODO: Unchecked conversions should probably be removed, but the PIMA schema relies on this, right now.</ID>
    <ID>ForbiddenComment:ProcessDataCommands.kt$ProcessData$// todo: put these strategies into metadata so we can load them from a file</ID>
    <ID>ForbiddenComment:Report.kt$Report$// TODO: Tech Debt - Made this var instead of val so we can update the report ID after creation in the async process</ID>
    <ID>ForbiddenComment:Report.kt$Report.Companion$// todo: extend this to use the APHL naming convention</ID>
    <ID>ForbiddenComment:ReportFunction.kt$ReportFunction$// TODO: Make this so that we check sender's configuration if there is no param type, this is blocked by</ID>
    <ID>ForbiddenComment:SendFunction.kt$SendFunction$// TODO: Next action should be WIPE when implemented</ID>
    <ID>ForbiddenComment:SimpleReportTests.kt$SimpleReportTests.Companion$// TODO: should we throw an error if we are adding the same key twice?</ID>
    <ID>ForbiddenComment:TokenAuthentication.kt$FindSenderKeyInSettings$* This is used during validation of a SenderToken. * * Implementation of a callback function used to find the public key for * a given Sender, kid, and alg. Lookup in the Settings table. * todo: the FHIR spec calls for allowing a set of keys. However, this callback only allows for one.</ID>
    <ID>ForbiddenComment:TransportType.kt$EmailTransportType$// TODO: default to a better choice</ID>
    <ID>ForbiddenComment:WorkflowEngine.kt$WorkflowEngine$// TODO: Tech Debt - update this when we are moving to storing internally-formatted report as part of</ID>
    <ID>ForbiddenComment:WorkflowEngine.kt$WorkflowEngine$// TODO: Tech debt, should not be getting errors and warnings as side effect work, should be returning something</ID>
    <ID>ForbiddenComment:WorkflowEngine.kt$WorkflowEngine$// TODO: This could be moved to a utility/reports.kt or something like that, as it is not really part of workflow</ID>
    <ID>FunctionNaming:HistoryFunctions.kt$Facility.Builder$fun CLIA(CLIA: String)</ID>
    <ID>FunctionParameterNaming:HistoryFunctions.kt$Facility.Builder$CLIA: String</ID>
    <ID>ImplicitDefaultLocale:Simulator.kt$Simulator$String.format( "%.2f", (result.sumMillisAllSubmissions / 1000.0) / result.totalSubmissionsCount )</ID>
    <ID>ImplicitDefaultLocale:Simulator.kt$Simulator$String.format( "%.2f", result.totalSubmissionsCount.toDouble() / (result.elapsedMillisForWholeSimulation / 1000.0) )</ID>
    <ID>ImplicitDefaultLocale:Simulator.kt$Simulator$String.format("%.2f", itemsPerSecond)</ID>
    <ID>ImplicitDefaultLocale:Simulator.kt$Simulator$String.format("%.2f", totalSubmissions.toFloat() / (totalTime / 1000.0))</ID>
    <ID>ImplicitDefaultLocale:TestReportStream.kt$Parallel$String.format( "%.2f", (totalMillisAllSubmissions / 1000.0) / totalSubmissionsCount )</ID>
    <ID>ImplicitDefaultLocale:TestReportStream.kt$Parallel$String.format( "%.2f", totalSubmissionsCount.toDouble() / (elapsedMillisTotal / 1000.0) )</ID>
    <ID>LargeClass:Element.kt$Element</ID>
    <ID>LargeClass:Hl7Serializer.kt$Hl7Serializer : Logging</ID>
    <ID>LargeClass:Hl7SerializerTests.kt$Hl7SerializerTests</ID>
    <ID>LongMethod:ActionHistoryTests.kt$ActionHistoryTests$@Test fun `test prettyPrintDestinations`()</ID>
    <ID>LongMethod:CompareData.kt$CompareCsvData$ fun compareCsvRow( actualRow: List&lt;String>, expectedRow: List&lt;String>, expectedHeaders: List&lt;String>, schema: Schema, actualRowNum: Int, result: CompareData.Result ): Boolean</ID>
    <ID>LongMethod:CompareData.kt$CompareHl7Data$ fun compare( expected: InputStream, actual: InputStream, result: CompareData.Result = CompareData.Result() ): CompareData.Result</ID>
    <ID>LongMethod:CsvSerializer.kt$CsvSerializer$fun readExternal( schemaName: String, input: InputStream, sources: List&lt;Source>, destination: Receiver? = null, defaultValues: Map&lt;String, String> = emptyMap(), ): ReadResult</ID>
    <ID>LongMethod:CsvSerializerTests.kt$CsvSerializerTests$@Test fun `test cardinality`()</ID>
    <ID>LongMethod:Element.kt$Element$ fun checkForError(formattedValue: String, format: String? = null): ResponseMessage?</ID>
    <ID>LongMethod:Element.kt$Element$ fun toFormatted( normalizedValue: String, format: String? = null, ): String</ID>
    <ID>LongMethod:Element.kt$Element$ fun toNormalized(formattedValue: String, format: String? = null): String</ID>
    <ID>LongMethod:Element.kt$Element$fun toNormalized(subValues: List&lt;SubValue>): String</ID>
    <ID>LongMethod:ElementTests.kt$ElementTests$@Test fun `test normalize and formatted round-trips`()</ID>
    <ID>LongMethod:HistoryFunctions.kt$BaseHistoryFunction$fun getReports( request: HttpRequestMessage&lt;String?>, context: ExecutionContext, organizationName: String? = null ): HttpResponseMessage</ID>
    <ID>LongMethod:Hl7Serializer.kt$Hl7Serializer$ fun convertMessageToMap(message: String, schema: Schema): RowResult</ID>
    <ID>LongMethod:Hl7Serializer.kt$Hl7Serializer$ internal fun decodeHl7DateTime( terser: Terser, element: Element, hl7Field: String, warnings: MutableList&lt;String> ): String</ID>
    <ID>LongMethod:Hl7Serializer.kt$Hl7Serializer$private fun buildMessage( message: ORU_R01, report: Report, row: Int, processingId: String = "T", )</ID>
    <ID>LongMethod:Hl7SerializerTests.kt$Hl7SerializerTests$@Test fun `test XTN phone decoding`()</ID>
    <ID>LongMethod:Hl7SerializerTests.kt$Hl7SerializerTests$@Test fun `test cliaForSender`()</ID>
    <ID>LongMethod:Hl7SerializerTests.kt$Hl7SerializerTests$@Test fun `test date time decoding`()</ID>
    <ID>LongMethod:Hl7Tests.kt$BadHl7$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:LookupTableFunctionsTests.kt$LookupTableFunctionsTests$@Test fun `create table test`()</ID>
    <ID>LongMethod:MetadataTests.kt$MetadataTests$@Test fun `load database lookup table updates test`()</ID>
    <ID>LongMethod:MetadataTests.kt$MetadataTests$@Test fun `test schema contamination`()</ID>
    <ID>LongMethod:ProcessDataCommands.kt$ProcessData$override fun run()</ID>
    <ID>LongMethod:RedoxTransport.kt$RedoxTransport$override fun send( transportType: TransportType, header: WorkflowEngine.Header, sentReportId: ReportId, retryItems: RetryItems?, context: ExecutionContext, actionHistory: ActionHistory, ): RetryItems?</ID>
    <ID>LongMethod:Report.kt$Report$ fun getDeidentifiedResultMetaData(): List&lt;CovidResultMetadata></ID>
    <ID>LongMethod:ReportFunction.kt$ReportFunction$ private fun processRequest( request: HttpRequestMessage&lt;String?>, sender: Sender, context: ExecutionContext, workflowEngine: WorkflowEngine, actionHistory: ActionHistory ): HttpResponseMessage</ID>
    <ID>LongMethod:ReportFunction.kt$ReportFunction$private fun validateRequest(engine: WorkflowEngine, request: HttpRequestMessage&lt;String?>): ValidatedRequest</ID>
    <ID>LongMethod:SettingsTest.kt$SettingsTest$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:Simulator.kt$Simulator$ fun runOneSimulation( simulation: Simulation, environment: Environment, options: CoolTestOptions ): SimulatorResult</ID>
    <ID>LongMethod:TestReportStream.kt$Parallel$fun runTheParallelTest( file: File, numThreads: Int, numRounds: Int, environment: Environment, options: CoolTestOptions ): Boolean</ID>
    <ID>LongMethod:TestReportStream.kt$QualityFilter$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:TestReportStream.kt$RepeatWaters$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:TestReportStream.kt$SantaClaus$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:WatersAuthTests.kt$WatersAuthTests$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>LongMethod:WorkflowEngine.kt$WorkflowEngine$ fun resendEvent( reportId: ReportId, receiver: Receiver, sendFailedOnly: Boolean, isTest: Boolean, msgs: MutableList&lt;String>, )</ID>
    <ID>LongParameterList:ActionHistory.kt$ActionHistory$( jsonGen: JsonGenerator, orgReceiver: Receiver, organization: Organization, sendingAt: OffsetDateTime?, countToPrint: Int, reportOptions: Options, reportId: ReportId )</ID>
    <ID>LongParameterList:ActionHistory.kt$ActionHistory$( receiver: Receiver, sentReportId: ReportId, fileName: String?, params: String, result: String, itemCount: Int )</ID>
    <ID>LongParameterList:CompareData.kt$CompareCsvData$( actualRow: List&lt;String>, expectedRow: List&lt;String>, expectedHeaders: List&lt;String>, schema: Schema, actualRowNum: Int, result: CompareData.Result )</ID>
    <ID>LongParameterList:CompareData.kt$CompareHl7Data$( actualFieldValue: String, expectedFieldValue: String, recordNum: Int, fieldSpec: String, fieldName: String, result: CompareData.Result )</ID>
    <ID>LongParameterList:CompareData.kt$CompareHl7Data$( recordNum: Int, fieldSpec: String, fieldName: String, actualFieldContents: Array&lt;Type>, expectedFieldContents: Array&lt;Type>, result: CompareData.Result )</ID>
    <ID>LongParameterList:CsvSerializer.kt$CsvSerializer$( schemaName: String, input: InputStream, sources: List&lt;Source>, destination: Receiver? = null, blobReportId: ReportId? = null, useDefaultsForMissing: Boolean = false )</ID>
    <ID>LongParameterList:DatabaseAccess.kt$DatabaseAccess$( reportId: ReportId, nextAction: TaskAction, nextActionAt: OffsetDateTime?, retryToken: String?, finishedField: Field&lt;OffsetDateTime>, txn: DataAccessTransaction? )</ID>
    <ID>LongParameterList:DocumentationFactory.kt$DocumentationFactory$( schema: Schema, outputDir: String = ".", outputFileName: String? = null, includeTimestamps: Boolean = false, generateMarkupFile: Boolean = true, generateHtmlFile: Boolean = false )</ID>
    <ID>LongParameterList:Event.kt$ProcessEvent$( eventAction: EventAction, val reportId: UUID, val options: Options, val defaults: Map&lt;String, String>, val routeTo: List&lt;String>, at: OffsetDateTime? = null, val retryToken: RetryToken? = null )</ID>
    <ID>LongParameterList:FileUtilities.kt$FileUtilities.Companion$( metadata: Metadata, sender: Sender, count: Int, targetStates: String? = null, targetCounties: String? = null, locale: Locale? = null )</ID>
    <ID>LongParameterList:FileUtilities.kt$FileUtilities.Companion$( metadata: Metadata, settings: SettingsProvider, sender: Sender, count: Int, targetStates: String? = null, targetCounties: String? = null, directory: String = ".", format: Report.Format = Report.Format.CSV, locale: Locale? = null )</ID>
    <ID>LongParameterList:FileUtilities.kt$FileUtilities.Companion$( report: Report, format: Report.Format, metadata: Metadata, outputDir: String?, outputFileName: String?, settings: SettingsProvider )</ID>
    <ID>LongParameterList:HistoryFunctions.kt$ReportView$( val sent: Long?, val via: String?, val positive: Long?, val total: Long?, val fileType: String?, val type: String?, val reportId: String?, val expires: Long?, val sendingOrg: String?, val receivingOrg: String?, val receivingOrgSvc: String?, val facilities: ArrayList&lt;Facility>?, val actions: ArrayList&lt;Action>?, val displayName: String?, val content: String?, val fileName: String?, val mimeType: String? )</ID>
    <ID>LongParameterList:Hl7Serializer.kt$Hl7Serializer$( terser: Terser, element: Element, aoeRep: Int, date: String, value: String, report: Report, row: Int, units: String? = null, suppressQst: Boolean = false, )</ID>
    <ID>LongParameterList:Hl7Serializer.kt$Hl7Serializer$( terser: Terser, element: Element, hl7Field: String, report: Report, row: Int, config: Hl7Configuration? = null )</ID>
    <ID>LongParameterList:HttpUtilities.kt$HttpUtilities.Companion$( environment: Environment, bytes: ByteArray, sendingOrgClient: Sender, key: String?, option: Options? = null, asyncProcessMode: Boolean = false, )</ID>
    <ID>LongParameterList:HttpUtilities.kt$HttpUtilities.Companion$( environment: Environment, file: File, sendingOrgClient: Sender, asyncProcessMode: Boolean = false, key: String? = null, option: Options? = null, )</ID>
    <ID>LongParameterList:ITransport.kt$ITransport$( transportType: TransportType, header: WorkflowEngine.Header, sentReportId: ReportId, retryItems: RetryItems?, context: ExecutionContext, actionHistory: ActionHistory, )</ID>
    <ID>LongParameterList:Jwk.kt$Jwk$( val kty: String, // Key type (Alg family). eg, RSA, EC, oct val use: String? = null, // Intended use. eg, sig, enc. val keyOps: String? = null, // key_ops: Intended use operations. eg, sign, verify, encrypt val alg: String? = null, var kid: String? = null, // key Id val x5u: String? = null, // URI ref to certificate val x5c: List&lt;String>? = null, // PKIX certificates. JSON array of String val x5t: String? = null, // certificate thumbprint // Algorithm specific fields val n: String? = null, // RSA val e: String? = null, // RSA val d: String? = null, // EC and RSA private val crv: String? = null, // EC val p: String? = null, // RSA private val q: String? = null, // RSA private val dp: String? = null, // RSA private val dq: String? = null, // RSA private val qi: String? = null, // RSA private val x: String? = null, // EC val y: String? = null, // EC val k: String? = null, // symmetric key, eg oct )</ID>
    <ID>LongParameterList:LookupTable.kt$LookupTable$( searchColumn: String, searchValue: String, lookupColumn: String, canonicalize: (String) -> String, commonWords: List&lt;String> = emptyList(), filterColumn: String? = null, filterValue: String? = null, )</ID>
    <ID>LongParameterList:Organization.kt$DeepOrganization$( name: String, description: String, jurisdiction: Jurisdiction, stateCode: String? = null, countyName: String? = null, val senders: List&lt;Sender> = emptyList(), val receivers: List&lt;Receiver> = emptyList(), )</ID>
    <ID>LongParameterList:Receiver.kt$Receiver$( val name: String, val organizationName: String, val topic: String, val customerStatus: CustomerStatus = CustomerStatus.INACTIVE, val translation: TranslatorConfiguration, val jurisdictionalFilter: List&lt;String> = emptyList(), val qualityFilter: List&lt;String> = emptyList(), // If this is true, then do the NOT of 'qualityFilter'. Like a 'grep -v' val reverseTheQualityFilter: Boolean = false, val deidentify: Boolean = false, val timing: Timing? = null, val description: String = "", val transport: TransportType? = null, val externalName: String? = null, )</ID>
    <ID>LongParameterList:Report.kt$Report$( schema: Schema, values: List&lt;List&lt;String>>, source: TestSource, destination: Receiver? = null, bodyFormat: Format? = null, itemLineage: List&lt;ItemLineage>? = null, metadata: Metadata? = null )</ID>
    <ID>LongParameterList:Report.kt$Report$( schema: Schema, values: List&lt;List&lt;String>>, sources: List&lt;Source>, destination: Receiver? = null, bodyFormat: Format? = null, itemLineage: List&lt;ItemLineage>? = null, id: ReportId? = null, // If constructing from blob storage, must pass in its UUID here. Otherwise null. metadata: Metadata )</ID>
    <ID>LongParameterList:Report.kt$Report$( schema: Schema, values: Map&lt;String, List&lt;String>>, source: Source, destination: Receiver? = null, bodyFormat: Format? = null, itemLineage: List&lt;ItemLineage>? = null, metadata: Metadata )</ID>
    <ID>LongParameterList:Report.kt$Report.Companion$( id: ReportId, schemaName: String, fileFormat: Format?, createdDateTime: OffsetDateTime, nameFormat: String = "standard", translationConfig: TranslatorConfiguration? = null, metadata: Metadata )</ID>
    <ID>LongParameterList:Report.kt$Report.Companion$( id: ReportId, schemaName: String, fileFormat: Format?, createdDateTime: OffsetDateTime, translationConfig: TranslatorConfiguration? = null, metadata: Metadata )</ID>
    <ID>LongParameterList:ReportFunction.kt$ReportFunction$( report: Report, workflowEngine: WorkflowEngine, options: Options, defaults: Map&lt;String, String>, routeTo: List&lt;String>, actionHistory: ActionHistory )</ID>
    <ID>LongParameterList:SendFunction.kt$SendFunction$( @QueueTrigger(name = "msg", queueName = send) message: String, context: ExecutionContext, @BindingName("Id") messageId: String? = null, @BindingName("DequeueCount") dequeueCount: Int? = null, @BindingName("NextVisibleTime") nextVisibleTime: Date? = null, @BindingName("InsertionTime") insertionTime: Date? = null, )</ID>
    <ID>LongParameterList:SendFunction.kt$SendFunction$( nextRetryItems: List&lt;String>, reportId: ReportId, serviceName: String, retryToken: RetryToken?, context: ExecutionContext, actionHistory: ActionHistory, )</ID>
    <ID>LongParameterList:Sender.kt$Sender$( val name: String, val organizationName: String, val format: Format, val topic: String, val customerStatus: CustomerStatus = CustomerStatus.INACTIVE, val schemaName: String, val keys: List&lt;JwkSet>? = null // used to track server-to-server auths for this Sender via public keys sets )</ID>
    <ID>LongParameterList:SettingsFacade.kt$ReceiverAPI$( name: String, organizationName: String, topic: String, customerStatus: CustomerStatus = CustomerStatus.INACTIVE, translation: TranslatorConfiguration, jurisdictionalFilter: List&lt;String> = emptyList(), qualityFilter: List&lt;String> = emptyList(), reverseTheQualityFilter: Boolean = false, deidentify: Boolean = false, timing: Timing? = null, description: String = "", transport: TransportType? = null, override var meta: SettingMetadata?, )</ID>
    <ID>LongParameterList:SettingsFacade.kt$SenderAPI$( name: String, organizationName: String, format: Format, topic: String, customerStatus: CustomerStatus = CustomerStatus.INACTIVE, schemaName: String, override var meta: SettingMetadata?, )</ID>
    <ID>LongParameterList:TestReportStream.kt$CoolTest$( reportId: ReportId, receivers: List&lt;Receiver>, totalItems: Int, filterOrgName: Boolean = false, silent: Boolean = false, maxPollSecs: Int = 180, pollSleepSecs: Int = 20, // I had this as every 5 secs, but was getting failures. The queries run unfastly. asyncProcessMode: Boolean = false )</ID>
    <ID>LongParameterList:TestReportStream.kt$Merge$( reportIds: List&lt;ReportId>, receivers: List&lt;Receiver>, itemsPerReport: Int, silent: Boolean = false, maxPollSecs: Int = 180, pollSleepSecs: Int = 20, )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( // Immutable objects can be shared between every function call val metadata: Metadata = WorkflowEngine.metadata, val settings: SettingsProvider = WorkflowEngine.settings, val hl7Serializer: Hl7Serializer = WorkflowEngine.hl7Serializer, val csvSerializer: CsvSerializer = WorkflowEngine.csvSerializer, val redoxSerializer: RedoxSerializer = WorkflowEngine.redoxSerializer, val translator: Translator = Translator(metadata, settings), // New connection for every function val db: DatabaseAccess = databaseAccess, val blob: BlobAccess = BlobAccess(csvSerializer, hl7Serializer, redoxSerializer), val queue: QueueAccess = QueueAccess, val sftpTransport: SftpTransport = SftpTransport(), val redoxTransport: RedoxTransport = RedoxTransport(), val as2Transport: AS2Transport = AS2Transport(), val ftpsTransport: FTPSTransport = FTPSTransport(), )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( context: ExecutionContext, report: Report, options: Options, defaults: Map&lt;String, String>, routeTo: List&lt;String>, warnings: MutableList&lt;ResultDetail>, actionHistory: ActionHistory, )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( nextAction: Event, report: Report, actionHistory: ActionHistory, receiver: Receiver, txn: Configuration? = null, context: ExecutionContext? = null )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( report: Report, receiver: Receiver, context: ExecutionContext, options: Options, actionHistory: ActionHistory, txn: DataAccessTransaction )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( reportId: ReportId, currentEventAction: Event.EventAction, nextEventAction: Event.EventAction, nextActionAt: OffsetDateTime? = null, retryToken: String? = null, txn: DataAccessTransaction, )</ID>
    <ID>LongParameterList:WorkflowEngine.kt$WorkflowEngine$( task: Task, reportFile: ReportFile, itemLineages: List&lt;ItemLineage>?, organization: Organization?, receiver: Receiver?, fetchBlobBody: Boolean = true )</ID>
    <ID>LoopWithTooManyJumpStatements:CompareData.kt$CompareHl7Data$while (true) { try { val actualSegmentName = actualTerser.finder.iterate(true, true) val expectedSegmentName = expectedTerser.finder.iterate(true, true) if (actualSegmentName != expectedSegmentName) { result.errors.add( "Actual HL7 segment name does not match expected. " + "Actual: $actualSegmentName, Expected: $expectedSegmentName" ) passed = false break } // The HAPI finder iteration does not give a clear indication when it is done with the entire // message vs an error when it is set to not loop, but with loop=true we get an empty segment name. if (actualSegmentName.isNullOrBlank() || expectedSegmentName.isNullOrBlank()) { if (!expectedSegmentName.isNullOrBlank()) { result.errors.add( "There is an extra segment named $expectedSegmentName missing from " + " the actual message. " ) passed = false } break } val actualSegment = actualTerser.getSegment(actualSegmentName) val expectedSegment = expectedTerser.getSegment(expectedSegmentName) if (actualSegment.numFields() != expectedSegment.numFields()) { result.errors.add( "Actual number of fields in HL7 segment does not match expected. " + "Actual: ${actualSegment.numFields()}, Expected: ${expectedSegment.numFields()}" ) passed = false break } // Loop through all the fields in the segment. for (fieldIndex in 1..actualSegment.numFields()) { val actualField = actualSegment.getField(fieldIndex) val expectedField = expectedSegment.getField(fieldIndex) passed = passed and compareField( recordNum, "$actualSegmentName-$fieldIndex", actualSegment.names[fieldIndex - 1], actualField, expectedField, result ) } } catch (e: HL7Exception) { result.errors.add("There was an error parsing the HL7 messages: $e") passed = false } }</ID>
    <ID>MagicNumber:AzureCredentialService.kt$AzureCredentialService$250L</ID>
    <ID>MagicNumber:AzureCredentialService.kt$AzureCredentialService$3</ID>
    <ID>MagicNumber:AzureSecretService.kt$AzureSecretService$250L</ID>
    <ID>MagicNumber:AzureSecretService.kt$AzureSecretService$3</ID>
    <ID>MagicNumber:CheckFunction.kt$CheckFunction$100000</ID>
    <ID>MagicNumber:CheckFunction.kt$CheckFunction$5</ID>
    <ID>MagicNumber:CovidResultMetaDataFunction.kt$CovidResultMetaDataFunction$30</ID>
    <ID>MagicNumber:DatabaseAccess.kt$DatabaseAccess$30</ID>
    <ID>MagicNumber:DatabaseLookupTableAccess.kt$DatabaseLookupTableAccess$5000</ID>
    <ID>MagicNumber:Element.kt$Element$3</ID>
    <ID>MagicNumber:Element.kt$Element$4</ID>
    <ID>MagicNumber:Element.kt$Element$6</ID>
    <ID>MagicNumber:Element.kt$Element$9999999999L</ID>
    <ID>MagicNumber:Element.kt$Element.Companion$3</ID>
    <ID>MagicNumber:Element.kt$Element.Companion$4</ID>
    <ID>MagicNumber:EmailEngineFunction.kt$EmailScheduleEngine$200</ID>
    <ID>MagicNumber:EmailEngineFunction.kt$EmailScheduleEngine$299</ID>
    <ID>MagicNumber:Environment.kt$Environment.Companion$443</ID>
    <ID>MagicNumber:Environment.kt$Environment.Companion$80</ID>
    <ID>MagicNumber:Event.kt$Event.Companion$3</ID>
    <ID>MagicNumber:Event.kt$Event.Companion$4</ID>
    <ID>MagicNumber:Event.kt$Event.Companion$5</ID>
    <ID>MagicNumber:Event.kt$Event.Companion$6</ID>
    <ID>MagicNumber:Event.kt$Event.Companion$7</ID>
    <ID>MagicNumber:FTPSTransport.kt$FTPSTransport.Companion$10000</ID>
    <ID>MagicNumber:FTPSTransport.kt$FTPSTransport.Companion$100000</ID>
    <ID>MagicNumber:FTPSTransport.kt$FTPSTransport.Companion$1024</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$10</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$100</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$120</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$18</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$364</ID>
    <ID>MagicNumber:FakeReport.kt$FakeDataService$5</ID>
    <ID>MagicNumber:FileNameTemplate.kt$Rand6$1000000</ID>
    <ID>MagicNumber:FileNameTemplate.kt$Rand6$6</ID>
    <ID>MagicNumber:FileNameTemplate.kt$RegexReplace$3</ID>
    <ID>MagicNumber:HashicorpVaultCredentialService.kt$HashicorpVaultCredentialService$204</ID>
    <ID>MagicNumber:HistoryFunctions.kt$BaseHistoryFunction$1000</ID>
    <ID>MagicNumber:HistoryFunctions.kt$BaseHistoryFunction$3</ID>
    <ID>MagicNumber:HistoryFunctions.kt$BaseHistoryFunction$30L</ID>
    <ID>MagicNumber:HistoryFunctions.kt$BaseHistoryFunction$7</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$10</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$3</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$32</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$5</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$50</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$6</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$7</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$8</ID>
    <ID>MagicNumber:Hl7Serializer.kt$Hl7Serializer$99</ID>
    <ID>MagicNumber:JtiCache.kt$JtiCache$5</ID>
    <ID>MagicNumber:JurisdictionalFilters.kt$IsValidCLIA$10</ID>
    <ID>MagicNumber:LookupTableCommands.kt$LookupTableEndpointUtilities$1000</ID>
    <ID>MagicNumber:LookupTableCommands.kt$LookupTableEndpointUtilities$45000</ID>
    <ID>MagicNumber:LookupTableCommands.kt$LookupTableLoadAllCommand$10</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$10</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$11</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$12</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$13</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$14</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$15</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$16</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$17</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$18</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$19</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$20</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$21</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$22</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$23</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$3</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$4</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$5</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$6</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$7</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$8</ID>
    <ID>MagicNumber:MetaDataFunction.kt$MetaDataFunction$9</ID>
    <ID>MagicNumber:OktaCommands.kt$LoginCommand$1000</ID>
    <ID>MagicNumber:OktaCommands.kt$LoginCommand$200</ID>
    <ID>MagicNumber:OktaCommands.kt$LoginCommand$32</ID>
    <ID>MagicNumber:OktaCommands.kt$OktaCommand.Companion$5</ID>
    <ID>MagicNumber:Receiver.kt$Receiver.Timing$24</ID>
    <ID>MagicNumber:Receiver.kt$Receiver.Timing$60</ID>
    <ID>MagicNumber:RedoxTransport.kt$RedoxTransport$1000</ID>
    <ID>MagicNumber:Report.kt$Report$12</ID>
    <ID>MagicNumber:Report.kt$Report$28</ID>
    <ID>MagicNumber:RequeueFunction.kt$RequeueFunction$4</ID>
    <ID>MagicNumber:Scope.kt$Scope.Companion$3</ID>
    <ID>MagicNumber:SendFunction.kt$120L</ID>
    <ID>MagicNumber:SendFunction.kt$3</ID>
    <ID>MagicNumber:SendFunction.kt$30L</ID>
    <ID>MagicNumber:SendFunction.kt$4</ID>
    <ID>MagicNumber:SendFunction.kt$5</ID>
    <ID>MagicNumber:SendFunction.kt$5L</ID>
    <ID>MagicNumber:SendFunction.kt$75L</ID>
    <ID>MagicNumber:SendFunction.kt$SendFunction$30</ID>
    <ID>MagicNumber:SendFunction.kt$SendFunction$31</ID>
    <ID>MagicNumber:SendFunction.kt$SendFunction$60</ID>
    <ID>MagicNumber:SenderUtils.kt$SenderUtils.Companion$1000</ID>
    <ID>MagicNumber:SftpTransport.kt$SftpTransport.Companion$120000</ID>
    <ID>MagicNumber:TokenAuthentication.kt$TokenAuthentication$1000</ID>
    <ID>MagicNumber:TokenAuthentication.kt$TokenAuthentication$300</ID>
    <ID>MagicNumber:TokenAuthentication.kt$TokenAuthentication$60</ID>
    <ID>MagicNumber:main.kt$GenerateDocs$3</ID>
    <ID>MaxLineLength:Authentication.kt$AuthenticationVerifier$*</ID>
    <ID>MaxLineLength:CompareData.kt$CompareCsvData$// This is not a true date/time since it was not parse, probably a date. Compare as strings.</ID>
    <ID>MaxLineLength:CsvSerializer.kt$CsvSerializer$*</ID>
    <ID>MaxLineLength:CsvSerializerTests.kt$CsvSerializerTests$ MSH|^~</ID>
    <ID>MaxLineLength:CsvSerializerTests.kt$CsvSerializerTests$ OBR|1|73a6e9bd-aaec-418e-813a-0ad33366ca85||94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN|||202102090000-0600|202102090000-0600||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI|^WPN^^^1^386^6825220|||||202102090000-0600|||F</ID>
    <ID>MaxLineLength:CsvSerializerTests.kt$CsvSerializerTests$ OBX|1|CWE|94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN||260415000^Not detected^SCT|||N^Normal (applies to non-numeric results)^HL70078|||F|||202102090000-0600|||CareStart COVID-19 Antigen test_Access Bio, Inc._EUA^^99ELR||202102090000-0600||||Avante at Ormond Beach^^^^^CLIA&amp;2.16.840.1.113883.4.7&amp;ISO^^^^10D0876999^CLIA|170 North King Road^^Ormond Beach^FL^32174^^^^12127</ID>
    <ID>MaxLineLength:CsvSerializerTests.kt$CsvSerializerTests$ ORC|RE|73a6e9bd-aaec-418e-813a-0ad33366ca85|73a6e9bd-aaec-418e-813a-0ad33366ca85|||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI||^WPN^^^1^386^6825220|20210209||||||Avante at Ormond Beach|170 North King Road^^Ormond Beach^FL^32174^^^^12127|^WPN^^jbrush@avantecenters.com^1^407^7397506|^^^^32174</ID>
    <ID>MaxLineLength:CsvSerializerTests.kt$CsvSerializerTests$ PID|1||2a14112c-ece1-4f82-915c-7b3a8d152eda^^^Avante at Ormond Beach^PI||Doe^Kareem^Millie^^^^L||19580810|F||2106-3^White^HL70005^^^^2.5.1|688 Leighann Inlet^^South Rodneychester^TX^67071||^PRN^^roscoe.wilkinson@email.com^1^211^2240784|||||||||U^Unknown^HL70189||||||||N</ID>
    <ID>MaxLineLength:Element.kt$Element$// Try to parse using a LocalDate pattern assuming it is in our canonical dateFormatter. Central timezone.</ID>
    <ID>MaxLineLength:EmailEngineFunction.kt$EmailScheduleEngine$/* So, the timer function doesn't fire on exactly every 5 minutes, so this is the "catch" at assure that anytime within less than 5 minutes of the last timer execution is valid (i.e. timer trigger fires at 11:59 but the cron for the schedule is at noon, without this, they don't "line up" and the schedule is always reported as shouldFire = false) This accounts for a difference in cron timers (Azure's and the one referenced here) */</ID>
    <ID>MaxLineLength:HistoryFunctions.kt$BaseHistoryFunction$// a user can now be part of a sender group as well, so find the first "non-sender" group in their claims</ID>
    <ID>MaxLineLength:Hl7Serializer.kt$Hl7Serializer$// If the phone number type is specified then make sure it is a phone, otherwise assume it is.</ID>
    <ID>MaxLineLength:Hl7Serializer.kt$Hl7Serializer$// If we have an area code or local number then let's use the new fields, otherwise try the deprecated field</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ MSH|^~</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ OBR|1|73a6e9bd-aaec-418e-813a-0ad33366ca85||94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN|||202102090000-0600|202102090000-0600||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI|^WPN^^^1^386^6825220|||||202102090000-0600|||F</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ OBX|1|CWE|94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN||260415000^Not detected^SCT|||N^Normal (applies to non-numeric results)^HL70078|||F|||202102090000-0600|||CareStart COVID-19 Antigen test_Access Bio, Inc._EUA^^99ELR||202102090000-0600||||Avante at Ormond Beach^^^^^CLIA&amp;2.16.840.1.113883.4.7&amp;ISO^^^^10D0876999^CLIA|170 North King Road^^Ormond Beach^FL^32174^^^^12127</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ ORC|RE|73a6e9bd-aaec-418e-813a-0ad33366ca85|73a6e9bd-aaec-418e-813a-0ad33366ca85|||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI||^WPN^^^1^386^6825220|20210209||||||Avante at Ormond Beach|170 North King Road^^Ormond Beach^FL^32174^^^^12127|^WPN^^jbrush@avantecenters.com^1^407^7397506|^^^^32174</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ PID|1||2a14112c-ece1-4f82-915c-7b3a8d152eda^^^Avante at Ormond Beach^PI||Doe^Kareem^Millie^^^^L||19580810|F||2106-3^White^HL70005^^^^2.5.1|688 Leighann Inlet^^South Rodneychester^TX^67071||^PRN^^roscoe.wilkinson@email.com^1^211^2240784|||||||||U^Unknown^HL70189||||||||N</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBR|1|73a6e9bd-aaec-418e-813a-0ad33366ca85||94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN|||202102090000-0600|202102090000-0600||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI|^WPN^^^1^386^6825220|||||202102090000-0600|||F</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBX|1|CWE|94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN||260415000^Not detected^SCT|||N^Normal (applies to non-numeric results)^HL70078|||F|||202102090000-0600|||CareStart COVID-19 Antigen test_Access Bio, Inc._EUA^^99ELR||202102090000-0600||||Avante at Ormond Beach^^^^^CLIA&amp;2.16.840.1.113883.4.7&amp;ISO^^^^10D0876999^CLIA|170 North King Road^^Ormond Beach^FL^32174^^^^12127</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBX|2|CWE|95418-0^Whether patient is employed in a healthcare setting^LN^^^^2.69||Y^Yes^HL70136||||||F|||202102090000-0600|||||||||||||||QST</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBX|3|CWE|95417-2^First test for condition of interest^LN^^^^2.69||Y^Yes^HL70136||||||F|||202102090000-0600|||||||||||||||QST</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBX|4|CWE|95421-4^Resides in a congregate care setting^LN^^^^2.69||N^No^HL70136||||||F|||202102090000-0600|||||||||||||||QST</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$OBX|5|CWE|95419-8^Has symptoms related to condition of interest^LN^^^^2.69||N^No^HL70136||||||F|||202102090000-0600|||||||||||||||QST</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$ORC|RE|73a6e9bd-aaec-418e-813a-0ad33366ca85|73a6e9bd-aaec-418e-813a-0ad33366ca85|||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI||^WPN^^^1^386^6825220|20210209||||||Avante at Ormond Beach|170 North King Road^^Ormond Beach^FL^32174^^^^12127|^WPN^^jbrush@avantecenters.com^1^407^7397506|^^^^32174</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$PID|1||2a14112c-ece1-4f82-915c-7b3a8d152eda^^^Avante at Ormond Beach^PI||</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$PID|1||2a14112c-ece1-4f82-915c-7b3a8d152eda^^^Avante at Ormond Beach^PI||Buckridge^Kareem^Millie^^^^L||19580810|F||2106-3^White^HL70005^^^^2.5.1|688 Leighann Inlet^^South Rodneychester^TX^67071||^NET^Internet^roscoe.wilkinson@email.com~(211)224-0784^PRN^PH^^1^211^2240784|||||||||U^Unknown^HL70189||||||||N</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$PID|1||2a14112c-ece1-4f82-915c-7b3a8d152eda^^^Avante at Ormond Beach^PI||Buckridge^Kareem^Millie^^^^L||19580810|F||2106-3^White^HL70005^^^^2.5.1|688 Leighann Inlet^^South Rodneychester^TX^67071||^PRN^^roscoe.wilkinson@email.com^1^211^2240784|||||||||U^Unknown^HL70189||||||||N</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$SPM|1|||258500001^Nasopharyngeal swab^SCT||||71836000^Nasopharyngeal structure (body structure)^SCT^^^^2020-09-01|||||||||202102090000-0600^202102090000-0600</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$sampleHl7Message</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$sampleHl7MessageWithRepeats</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$val</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$val csvContent = ByteArrayInputStream("senderId,testOrdered,testName,testCodingSystem,testResult,testResultText,testPerformed,testResultCodingSystem,testResultDate,testReportDate,testOrderedDate,specimenCollectedDate,deviceIdentifier,deviceName,specimenId,serialNumber,patientAge,patientAgeUnits,patientDob,patientRace,patientRaceText,patientEthnicity,patientEthnicityText,patientSex,patientZip,patientCounty,orderingProviderNpi,orderingProviderLname,orderingProviderFname,orderingProviderZip,performingFacility,performingFacilityName,performingFacilityStreet,performingFacilityStreet2,performingFacilityCity,performingFacilityState,performingFacilityZip,performingFacilityCounty,performingFacilityPhone,orderingFacilityName,orderingFacilityStreet,orderingFacilityStreet2,orderingFacilityCity,orderingFacilityState,orderingFacilityZip,orderingFacilityCounty,orderingFacilityPhone,specimenSource,patientNameLast,patientNameFirst,patientNameMiddle,patientUniqueId,patientHomeAddress,patientHomeAddress2,patientCity,patientState,patientPhone,patientPhoneArea,orderingProviderAddress,orderingProviderAddress2,orderingProviderCity,orderingProviderState,orderingProviderPhone,orderingProviderPhoneArea,firstTest,previousTestType,previousTestDate,previousTestResult,correctedTestId,healthcareEmployee,healthcareEmployeeType,symptomatic,symptomsList,hospitalized,hospitalizedCode,symptomsIcu,congregateResident,congregateResidentType,pregnant,pregnantText,patientEmail,reportingFacility\nfake,94531-1,SARS coronavirus 2 RNA panel - Respiratory specimen by NAA with probe detection,LN,260415000,Not Detected,94558-4,SCT,202110062022-0400,202110062022-0400,20211007,20211007,00382902560821,BD Veritor System for Rapid Detection of SARS-CoV-2*,4efd9df8-9424-4e50-b168-f3aa894bfa42,4efd9df8-9424-4e50-b168-f3aa894bfa42,45,yr,1975-10-10,2106-3,White,2135-2,Hispanic or Latino,M,93307,Kern County,1760085880,,,93312,05D2191150,Inovia Pharmacy,9902 Brimhall rd ste 100,,Bakersfield,CA,93312,Kern County,+16618297861,Inovia Pharmacy,9902 Brimhall rd ste 100,,Bakersfield,CA,93312,Kern County,+16618297861,445297001,Tapia,Jose,,e553c462-6bad-4e42-ab1e-0879b797aa31,1211 Dawn st,,Bakersfield,CA,+16614933107,661,9902 BRIMHALL RD STE 100,,BAKERSFIELD,CA,+16618297861,661,UNK,,,,,,,UNK,,NO,,NO,NO,,261665006,UNK,,1760085880".toByteArray()) // ktlint-disable max-line-length</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$val csvContentSenderNotFound = ByteArrayInputStream("senderId,testOrdered,testName,testCodingSystem,testResult,testResultText,testPerformed,testResultCodingSystem,testResultDate,testReportDate,testOrderedDate,specimenCollectedDate,deviceIdentifier,deviceName,specimenId,serialNumber,patientAge,patientAgeUnits,patientDob,patientRace,patientRaceText,patientEthnicity,patientEthnicityText,patientSex,patientZip,patientCounty,orderingProviderNpi,orderingProviderLname,orderingProviderFname,orderingProviderZip,performingFacility,performingFacilityName,performingFacilityStreet,performingFacilityStreet2,performingFacilityCity,performingFacilityState,performingFacilityZip,performingFacilityCounty,performingFacilityPhone,orderingFacilityName,orderingFacilityStreet,orderingFacilityStreet2,orderingFacilityCity,orderingFacilityState,orderingFacilityZip,orderingFacilityCounty,orderingFacilityPhone,specimenSource,patientNameLast,patientNameFirst,patientNameMiddle,patientUniqueId,patientHomeAddress,patientHomeAddress2,patientCity,patientState,patientPhone,patientPhoneArea,orderingProviderAddress,orderingProviderAddress2,orderingProviderCity,orderingProviderState,orderingProviderPhone,orderingProviderPhoneArea,firstTest,previousTestType,previousTestDate,previousTestResult,correctedTestId,healthcareEmployee,healthcareEmployeeType,symptomatic,symptomsList,hospitalized,hospitalizedCode,symptomsIcu,congregateResident,congregateResidentType,pregnant,pregnantText,patientEmail,reportingFacility\nfake,94531-1,SARS coronavirus 2 RNA panel - Respiratory specimen by NAA with probe detection,LN,260415000,Not Detected,94558-4,SCT,202110062022-0400,202110062022-0400,20211007,20211007,00382902560821,BD Veritor System for Rapid Detection of SARS-CoV-2*,4efd9df8-9424-4e50-b168-f3aa894bfa42,4efd9df8-9424-4e50-b168-f3aa894bfa42,45,yr,1975-10-10,2106-3,White,2135-2,Hispanic or Latino,M,93307,Kern County,1760085880,,,93312,05D2191150,Inovia Pharmacy,9902 Brimhall rd ste 100,,Bakersfield,CA,93312,Kern County,+16618297861,Inovia Pharmacy,9902 Brimhall rd ste 100,,Bakersfield,CA,93312,Kern County,+16618297861,445297001,Tapia,Jose,,e553c462-6bad-4e42-ab1e-0879b797aa31,1211 Dawn st,,Bakersfield,CA,+16614933107,661,9902 BRIMHALL RD STE 100,,BAKERSFIELD,CA,+16618297861,661,UNK,,,,,,,UNK,,NO,,NO,NO,,261665006,UNK,,1760085880".toByteArray()) // ktlint-disable max-line-length</ID>
    <ID>MaxLineLength:Hl7SerializerTests.kt$Hl7SerializerTests$val testRptSenderNotFound = csvSerializer.readExternal(schema, csvContentSenderNotFound, listOf(TestSource), receiverSenderNotFound).report ?: fail() // ktlint-disable max-line-length</ID>
    <ID>MaxLineLength:Hl7Tests.kt$BadHl7$OBX|1|CWE|94558-4^SARS-CoV-2 (COVID-19) Ag [Presence] in Respiratory specimen by Rapid immunoassay^LN||260415000^Not detected^SCT|||N^Normal (applies to non-numeric results)^HL70078|||F|||202102090000-0600|||CareStart COVID-19 Antigen test_Access Bio, Inc._EUA^^99ELR||202102090000-0600||||Avante at Ormond Beach^^^^^CLIA&amp;2.16.840.1.113883.19.4.6&amp;ISO^^^^10D08761999^CLIA|170 North King Road^^Ormond Beach^FL^32174^^^^12127</ID>
    <ID>MaxLineLength:Hl7Tests.kt$BadHl7$ORC|RE|73a6e9bd-aaec-418e-813a-0ad33366ca85|73a6e9bd-aaec-418e-813a-0ad33366ca85|||||||||1629082607^Eddin^Husam^^^^^^CMS&amp;2.16.840.1.113883.3.249&amp;ISO^^^^NPI||^WPN^^^1^386^6825220|202102090000-0500||||||Avante at Ormond Beach|170 North King Road^^Ormond Beach^IG^32174^^^^12127|^WPN^^jbrush@avantecenters.com^1^407^7397506|^^^^32174</ID>
    <ID>MaxLineLength:Hl7Tests.kt$BadHl7$PID|1|ABC123DF|AND234DA_PID3|PID_4_ALTID|Patlast^Patfirst^Mid||19670202|F|||4505 21 st^^LAKE COUNTRY^MD^FO||222-555-8484|||||MF0050356/15|</ID>
    <ID>MaxLineLength:Hl7Tests.kt$BadHl7$SPM|1|b518ef23-1d9a-40c1-ac4b-ed7b438dfc4b||258500001^Nasopharyngeal swab^SCT||||71836000^Nasopharyngeal structure (body structure)^SCT^^^^2020-09-01|||||||||20201102063552-0500|20201102063552-0500</ID>
    <ID>MaxLineLength:Hl7Tests.kt$BadHl7$val</ID>
    <ID>MaxLineLength:JurisdictionalFilters.kt$JurisdictionalFilter$*</ID>
    <ID>MaxLineLength:JwkTests.kt$JwkTests$ </ID>
    <ID>MaxLineLength:MapperTests.kt$MapperTests$// it should allow mapper tokens to be parsed with semi-colon literal values: i.e. "$dateFormat:some-valid-date-format"</ID>
    <ID>MaxLineLength:Mappers.kt$Obx17Mapper$*</ID>
    <ID>MaxLineLength:Mappers.kt$Obx17TypeMapper$*</ID>
    <ID>MaxLineLength:Mappers.kt$Obx8Mapper$*</ID>
    <ID>MaxLineLength:Mappers.kt$UseMapper$// TODO: Unchecked conversions should probably be removed, but the PIMA schema relies on this, right now.</ID>
    <ID>MaxLineLength:RedoxSerializer.kt$RedoxSerializer$// Escaping handles the case where the value contains an "|" or "&amp;" which will mess up Redox's HL7 generation</ID>
    <ID>MaxLineLength:SettingsProvider.kt$CustomerStatus$*</ID>
    <ID>MaxLineLength:TokenAuthenticationTests.kt$ </ID>
    <ID>MaxLineLength:TokenAuthenticationTests.kt$TokenAuthenticationTests$ </ID>
    <ID>MayBeConst:TokenAuthenticationTests.kt$// corresponding public key to above. val exampleKeyId = "11209921-860e-4b6d-8d7e-adc8778e1c6c"</ID>
    <ID>NestedBlockDepth:ActionHistory.kt$ActionHistory$ fun createResponseBody( options: Options, warnings: List&lt;ResultDetail>, errors: List&lt;ResultDetail>, verbose: Boolean, report: Report? = null ): String</ID>
    <ID>NestedBlockDepth:ActionHistory.kt$ActionHistory.Companion$ fun sanityCheckReports( tasks: List&lt;Task>?, reportFiles: Map&lt;ReportId, ReportFile>?, failOnError: Boolean = false )</ID>
    <ID>NestedBlockDepth:CompareData.kt$CompareCsvData$ fun compare( expected: InputStream, actual: InputStream, schema: Schema, result: CompareData.Result = CompareData.Result() ): CompareData.Result</ID>
    <ID>NestedBlockDepth:CompareData.kt$CompareCsvData$ fun compareCsvRow( actualRow: List&lt;String>, expectedRow: List&lt;String>, expectedHeaders: List&lt;String>, schema: Schema, actualRowNum: Int, result: CompareData.Result ): Boolean</ID>
    <ID>NestedBlockDepth:CompareData.kt$CompareHl7Data$ fun compare( expected: InputStream, actual: InputStream, result: CompareData.Result = CompareData.Result() ): CompareData.Result</ID>
    <ID>NestedBlockDepth:CompareData.kt$CompareHl7Data$ fun compareField( recordNum: Int, fieldSpec: String, fieldName: String, actualFieldContents: Array&lt;Type>, expectedFieldContents: Array&lt;Type>, result: CompareData.Result ): Boolean</ID>
    <ID>NestedBlockDepth:CompareData.kt$DataCompareTest$ private fun readTestConfig(configPathname: String): Map&lt;TestInput, List&lt;TestOutput>></ID>
    <ID>NestedBlockDepth:CompareData.kt$DataCompareTest$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>NestedBlockDepth:Element.kt$Element$ fun checkForError(formattedValue: String, format: String? = null): ResponseMessage?</ID>
    <ID>NestedBlockDepth:Element.kt$Element$fun toNormalized(subValues: List&lt;SubValue>): String</ID>
    <ID>NestedBlockDepth:HistoryFunctions.kt$BaseHistoryFunction$ fun checkAuthenticated(request: HttpRequestMessage&lt;String?>, context: ExecutionContext): AuthClaims?</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$ fun convertMessageToMap(message: String, schema: Schema): RowResult</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$ internal fun decodeHl7DateTime( terser: Terser, element: Element, hl7Field: String, warnings: MutableList&lt;String> ): String</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$ internal fun decodeHl7TelecomData(terser: Terser, element: Element, hl7Field: String): String</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$ private fun replaceValue( replaceValueMap: Map&lt;String, String>, terser: Terser, observationRepeats: Int )</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$private fun buildMessage( message: ORU_R01, report: Report, row: Int, processingId: String = "T", )</ID>
    <ID>NestedBlockDepth:Hl7Serializer.kt$Hl7Serializer$private fun setCodeComponent(terser: Terser, value: String, pathSpec: String, valueSetName: String?)</ID>
    <ID>NestedBlockDepth:RedoxSerializer.kt$RedoxSerializer$private fun createMessage(fields: List&lt;JsonField>, row: List&lt;String>): String</ID>
    <ID>NestedBlockDepth:SftpTransport.kt$SftpTransport.Companion$ fun uploadFile( sshClient: SSHClient, path: String, fileName: String, contents: ByteArray )</ID>
    <ID>NestedBlockDepth:SftpTransport.kt$SftpTransport.Companion$fun ls(sshClient: SSHClient, path: String, resourceFilter: RemoteResourceFilter?): List&lt;String></ID>
    <ID>NestedBlockDepth:SftpTransport.kt$SftpTransport.Companion$fun rm(sshClient: SSHClient, path: String, fileName: String)</ID>
    <ID>NestedBlockDepth:TestReportStream.kt$QualityFilter$ fun checkJsonItemCountForReceiver(receiver: Receiver, expectedCount: Int, json: String): Boolean</ID>
    <ID>NestedBlockDepth:TestReportStream.kt$SantaClaus$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>NewLineAtEndOfFile:AS2Transport.kt$gov.cdc.prime.router.transport.AS2Transport.kt</ID>
    <ID>NewLineAtEndOfFile:AS2TransportTests.kt$gov.cdc.prime.router.transport.AS2TransportTests.kt</ID>
    <ID>NewLineAtEndOfFile:ActionHistory.kt$gov.cdc.prime.router.azure.ActionHistory.kt</ID>
    <ID>NewLineAtEndOfFile:ActionHistoryTests.kt$gov.cdc.prime.router.azure.ActionHistoryTests.kt</ID>
    <ID>NewLineAtEndOfFile:Authentication.kt$gov.cdc.prime.router.azure.Authentication.kt</ID>
    <ID>NewLineAtEndOfFile:AuthenticationStrategy.kt$gov.cdc.prime.router.tokens.AuthenticationStrategy.kt</ID>
    <ID>NewLineAtEndOfFile:AuthenticationTests.kt$gov.cdc.prime.router.azure.AuthenticationTests.kt</ID>
    <ID>NewLineAtEndOfFile:AzureCredentialService.kt$gov.cdc.prime.router.credentials.AzureCredentialService.kt</ID>
    <ID>NewLineAtEndOfFile:AzureCredentialServiceTests.kt$gov.cdc.prime.router.credentials.AzureCredentialServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:AzureSecretService.kt$gov.cdc.prime.router.secrets.AzureSecretService.kt</ID>
    <ID>NewLineAtEndOfFile:AzureSecretServiceTests.kt$gov.cdc.prime.router.secrets.AzureSecretServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:BatchFunction.kt$gov.cdc.prime.router.azure.BatchFunction.kt</ID>
    <ID>NewLineAtEndOfFile:BlobAccess.kt$gov.cdc.prime.router.azure.BlobAccess.kt</ID>
    <ID>NewLineAtEndOfFile:BlobAccessTests.kt$gov.cdc.prime.router.azure.BlobAccessTests.kt</ID>
    <ID>NewLineAtEndOfFile:BlobStoreTransport.kt$gov.cdc.prime.router.transport.BlobStoreTransport.kt</ID>
    <ID>NewLineAtEndOfFile:CheckFunction.kt$gov.cdc.prime.router.azure.CheckFunction.kt</ID>
    <ID>NewLineAtEndOfFile:CompareData.kt$gov.cdc.prime.router.cli.tests.CompareData.kt</ID>
    <ID>NewLineAtEndOfFile:CompareDataTests.kt$gov.cdc.prime.router.cli.tests.CompareDataTests.kt</ID>
    <ID>NewLineAtEndOfFile:CovidResultMetaDataFunction.kt$gov.cdc.prime.router.azure.CovidResultMetaDataFunction.kt</ID>
    <ID>NewLineAtEndOfFile:Credential.kt$gov.cdc.prime.router.credentials.Credential.kt</ID>
    <ID>NewLineAtEndOfFile:CredentialManagement.kt$gov.cdc.prime.router.credentials.CredentialManagement.kt</ID>
    <ID>NewLineAtEndOfFile:CredentialService.kt$gov.cdc.prime.router.credentials.CredentialService.kt</ID>
    <ID>NewLineAtEndOfFile:CredentialServiceTests.kt$gov.cdc.prime.router.credentials.CredentialServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:CredentialTests.kt$gov.cdc.prime.router.credentials.CredentialTests.kt</ID>
    <ID>NewLineAtEndOfFile:CredentialsCli.kt$gov.cdc.prime.router.cli.CredentialsCli.kt</ID>
    <ID>NewLineAtEndOfFile:CsvComparer.kt$gov.cdc.prime.router.CsvComparer.kt</ID>
    <ID>NewLineAtEndOfFile:CsvFileTests.kt$gov.cdc.prime.router.CsvFileTests.kt</ID>
    <ID>NewLineAtEndOfFile:CsvSerializer.kt$gov.cdc.prime.router.serializers.CsvSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CsvSerializerTests.kt$gov.cdc.prime.router.serializers.CsvSerializerTests.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseAccess.kt$gov.cdc.prime.router.azure.DatabaseAccess.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseJtiCache.kt$gov.cdc.prime.router.tokens.DatabaseJtiCache.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseLookupTable.kt$gov.cdc.prime.router.metadata.DatabaseLookupTable.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseLookupTableAccess.kt$gov.cdc.prime.router.azure.DatabaseLookupTableAccess.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseLookupTableAccessTests.kt$gov.cdc.prime.router.azure.DatabaseLookupTableAccessTests.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseLookupTableTests.kt$gov.cdc.prime.router.metadata.DatabaseLookupTableTests.kt</ID>
    <ID>NewLineAtEndOfFile:DocumentationFactory.kt$gov.cdc.prime.router.DocumentationFactory.kt</ID>
    <ID>NewLineAtEndOfFile:DocumentationTests.kt$gov.cdc.prime.router.DocumentationTests.kt</ID>
    <ID>NewLineAtEndOfFile:Element.kt$gov.cdc.prime.router.Element.kt</ID>
    <ID>NewLineAtEndOfFile:ElementErrors.kt$gov.cdc.prime.router.ElementErrors.kt</ID>
    <ID>NewLineAtEndOfFile:ElementTests.kt$gov.cdc.prime.router.ElementTests.kt</ID>
    <ID>NewLineAtEndOfFile:EmailEngineFunction.kt$gov.cdc.prime.router.azure.EmailEngineFunction.kt</ID>
    <ID>NewLineAtEndOfFile:EmailTransport.kt$gov.cdc.prime.router.transport.EmailTransport.kt</ID>
    <ID>NewLineAtEndOfFile:EnvVarSecretService.kt$gov.cdc.prime.router.secrets.EnvVarSecretService.kt</ID>
    <ID>NewLineAtEndOfFile:Environment.kt$gov.cdc.prime.router.common.Environment.kt</ID>
    <ID>NewLineAtEndOfFile:EnvironmentTests.kt$gov.cdc.prime.router.common.EnvironmentTests.kt</ID>
    <ID>NewLineAtEndOfFile:Event.kt$gov.cdc.prime.router.azure.Event.kt</ID>
    <ID>NewLineAtEndOfFile:EventTest.kt$gov.cdc.prime.router.azure.EventTest.kt</ID>
    <ID>NewLineAtEndOfFile:FTPSTransport.kt$gov.cdc.prime.router.transport.FTPSTransport.kt</ID>
    <ID>NewLineAtEndOfFile:FakeReport.kt$gov.cdc.prime.router.FakeReport.kt</ID>
    <ID>NewLineAtEndOfFile:FakeReportTests.kt$gov.cdc.prime.router.FakeReportTests.kt</ID>
    <ID>NewLineAtEndOfFile:FileNameTemplate.kt$gov.cdc.prime.router.FileNameTemplate.kt</ID>
    <ID>NewLineAtEndOfFile:FileNameTemplateTests.kt$gov.cdc.prime.router.FileNameTemplateTests.kt</ID>
    <ID>NewLineAtEndOfFile:FileSettings.kt$gov.cdc.prime.router.FileSettings.kt</ID>
    <ID>NewLineAtEndOfFile:FileSettingsTests.kt$gov.cdc.prime.router.FileSettingsTests.kt</ID>
    <ID>NewLineAtEndOfFile:FileUtilities.kt$gov.cdc.prime.router.cli.FileUtilities.kt</ID>
    <ID>NewLineAtEndOfFile:HashicorpVaultCredentialService.kt$gov.cdc.prime.router.credentials.HashicorpVaultCredentialService.kt</ID>
    <ID>NewLineAtEndOfFile:HashicorpVaultCredentialServiceTests.kt$gov.cdc.prime.router.credentials.HashicorpVaultCredentialServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:HistoryFunctions.kt$gov.cdc.prime.router.azure.HistoryFunctions.kt</ID>
    <ID>NewLineAtEndOfFile:Hl7Serializer.kt$gov.cdc.prime.router.serializers.Hl7Serializer.kt</ID>
    <ID>NewLineAtEndOfFile:Hl7SerializerTests.kt$gov.cdc.prime.router.serializers.Hl7SerializerTests.kt</ID>
    <ID>NewLineAtEndOfFile:Hl7Tests.kt$gov.cdc.prime.router.cli.tests.Hl7Tests.kt</ID>
    <ID>NewLineAtEndOfFile:HttpUtilities.kt$gov.cdc.prime.router.azure.HttpUtilities.kt</ID>
    <ID>NewLineAtEndOfFile:ITransport.kt$gov.cdc.prime.router.transport.ITransport.kt</ID>
    <ID>NewLineAtEndOfFile:JtiCache.kt$gov.cdc.prime.router.tokens.JtiCache.kt</ID>
    <ID>NewLineAtEndOfFile:JurisdictionalFilterTests.kt$gov.cdc.prime.router.JurisdictionalFilterTests.kt</ID>
    <ID>NewLineAtEndOfFile:JurisdictionalFilters.kt$gov.cdc.prime.router.JurisdictionalFilters.kt</ID>
    <ID>NewLineAtEndOfFile:Jwk.kt$gov.cdc.prime.router.tokens.Jwk.kt</ID>
    <ID>NewLineAtEndOfFile:JwkTests.kt$gov.cdc.prime.router.tokens.JwkTests.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTable.kt$gov.cdc.prime.router.metadata.LookupTable.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTableCommands.kt$gov.cdc.prime.router.cli.LookupTableCommands.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTableCommandsTest.kt$gov.cdc.prime.router.cli.LookupTableCommandsTest.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTableFunctions.kt$gov.cdc.prime.router.azure.LookupTableFunctions.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTableFunctionsTests.kt$gov.cdc.prime.router.azure.LookupTableFunctionsTests.kt</ID>
    <ID>NewLineAtEndOfFile:LookupTableTests.kt$gov.cdc.prime.router.metadata.LookupTableTests.kt</ID>
    <ID>NewLineAtEndOfFile:MapperTests.kt$gov.cdc.prime.router.MapperTests.kt</ID>
    <ID>NewLineAtEndOfFile:Mappers.kt$gov.cdc.prime.router.Mappers.kt</ID>
    <ID>NewLineAtEndOfFile:MemoryCredentialService.kt$gov.cdc.prime.router.credentials.MemoryCredentialService.kt</ID>
    <ID>NewLineAtEndOfFile:MemoryJtiCache.kt$gov.cdc.prime.router.tokens.MemoryJtiCache.kt</ID>
    <ID>NewLineAtEndOfFile:MetaDataFunction.kt$gov.cdc.prime.router.azure.MetaDataFunction.kt</ID>
    <ID>NewLineAtEndOfFile:Metadata.kt$gov.cdc.prime.router.Metadata.kt</ID>
    <ID>NewLineAtEndOfFile:MetadataTests.kt$gov.cdc.prime.router.MetadataTests.kt</ID>
    <ID>NewLineAtEndOfFile:NullTransport.kt$gov.cdc.prime.router.transport.NullTransport.kt</ID>
    <ID>NewLineAtEndOfFile:OktaAuthentication.kt$gov.cdc.prime.router.tokens.OktaAuthentication.kt</ID>
    <ID>NewLineAtEndOfFile:OktaCommands.kt$gov.cdc.prime.router.cli.OktaCommands.kt</ID>
    <ID>NewLineAtEndOfFile:Organization.kt$gov.cdc.prime.router.Organization.kt</ID>
    <ID>NewLineAtEndOfFile:ProcessDataCommands.kt$gov.cdc.prime.router.cli.ProcessDataCommands.kt</ID>
    <ID>NewLineAtEndOfFile:ProcessFunction.kt$gov.cdc.prime.router.azure.ProcessFunction.kt</ID>
    <ID>NewLineAtEndOfFile:QueueAccess.kt$gov.cdc.prime.router.azure.QueueAccess.kt</ID>
    <ID>NewLineAtEndOfFile:ReadResult.kt$gov.cdc.prime.router.serializers.ReadResult.kt</ID>
    <ID>NewLineAtEndOfFile:Receiver.kt$gov.cdc.prime.router.Receiver.kt</ID>
    <ID>NewLineAtEndOfFile:ReceiverTests.kt$gov.cdc.prime.router.ReceiverTests.kt</ID>
    <ID>NewLineAtEndOfFile:RedoxSerializer.kt$gov.cdc.prime.router.serializers.RedoxSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:RedoxTransport.kt$gov.cdc.prime.router.transport.RedoxTransport.kt</ID>
    <ID>NewLineAtEndOfFile:RedoxTransportTests.kt$gov.cdc.prime.router.transport.RedoxTransportTests.kt</ID>
    <ID>NewLineAtEndOfFile:Report.kt$gov.cdc.prime.router.Report.kt</ID>
    <ID>NewLineAtEndOfFile:ReportFunction.kt$gov.cdc.prime.router.azure.ReportFunction.kt</ID>
    <ID>NewLineAtEndOfFile:ReportStreamSecretFinder.kt$gov.cdc.prime.router.tokens.ReportStreamSecretFinder.kt</ID>
    <ID>NewLineAtEndOfFile:ReportTests.kt$gov.cdc.prime.router.ReportTests.kt</ID>
    <ID>NewLineAtEndOfFile:RequeueFunction.kt$gov.cdc.prime.router.azure.RequeueFunction.kt</ID>
    <ID>NewLineAtEndOfFile:ResponseMessage.kt$gov.cdc.prime.router.ResponseMessage.kt</ID>
    <ID>NewLineAtEndOfFile:ResultDetail.kt$gov.cdc.prime.router.ResultDetail.kt</ID>
    <ID>NewLineAtEndOfFile:RetryToken.kt$gov.cdc.prime.router.transport.RetryToken.kt</ID>
    <ID>NewLineAtEndOfFile:Schema.kt$gov.cdc.prime.router.Schema.kt</ID>
    <ID>NewLineAtEndOfFile:SchemaTests.kt$gov.cdc.prime.router.SchemaTests.kt</ID>
    <ID>NewLineAtEndOfFile:Scope.kt$gov.cdc.prime.router.tokens.Scope.kt</ID>
    <ID>NewLineAtEndOfFile:SecretManagement.kt$gov.cdc.prime.router.secrets.SecretManagement.kt</ID>
    <ID>NewLineAtEndOfFile:SecretService.kt$gov.cdc.prime.router.secrets.SecretService.kt</ID>
    <ID>NewLineAtEndOfFile:SecretServiceTests.kt$gov.cdc.prime.router.secrets.SecretServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:SendFunction.kt$gov.cdc.prime.router.azure.SendFunction.kt</ID>
    <ID>NewLineAtEndOfFile:SendFunctionTests.kt$gov.cdc.prime.router.azure.SendFunctionTests.kt</ID>
    <ID>NewLineAtEndOfFile:Sender.kt$gov.cdc.prime.router.Sender.kt</ID>
    <ID>NewLineAtEndOfFile:SenderUtils.kt$gov.cdc.prime.router.tokens.SenderUtils.kt</ID>
    <ID>NewLineAtEndOfFile:SenderUtilsCommand.kt$gov.cdc.prime.router.cli.SenderUtilsCommand.kt</ID>
    <ID>NewLineAtEndOfFile:SettingCommands.kt$gov.cdc.prime.router.cli.SettingCommands.kt</ID>
    <ID>NewLineAtEndOfFile:SettingFacadeTests.kt$gov.cdc.prime.router.azure.SettingFacadeTests.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsFacade.kt$gov.cdc.prime.router.azure.SettingsFacade.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsFunctions.kt$gov.cdc.prime.router.azure.SettingsFunctions.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsProvider.kt$gov.cdc.prime.router.SettingsProvider.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsTest.kt$gov.cdc.prime.router.cli.tests.SettingsTest.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsUtilities.kt$gov.cdc.prime.router.cli.SettingsUtilities.kt</ID>
    <ID>NewLineAtEndOfFile:SftpTransport.kt$gov.cdc.prime.router.transport.SftpTransport.kt</ID>
    <ID>NewLineAtEndOfFile:SimpleReportTests.kt$gov.cdc.prime.router.SimpleReportTests.kt</ID>
    <ID>NewLineAtEndOfFile:Simulator.kt$gov.cdc.prime.router.cli.tests.Simulator.kt</ID>
    <ID>NewLineAtEndOfFile:Source.kt$gov.cdc.prime.router.Source.kt</ID>
    <ID>NewLineAtEndOfFile:TestKeys.kt$gov.cdc.prime.router.cli.tests.TestKeys.kt</ID>
    <ID>NewLineAtEndOfFile:TestReportStream.kt$gov.cdc.prime.router.cli.tests.TestReportStream.kt</ID>
    <ID>NewLineAtEndOfFile:TokenAuthentication.kt$gov.cdc.prime.router.tokens.TokenAuthentication.kt</ID>
    <ID>NewLineAtEndOfFile:TokenAuthenticationTests.kt$gov.cdc.prime.router.tokens.TokenAuthenticationTests.kt</ID>
    <ID>NewLineAtEndOfFile:TokenFunction.kt$gov.cdc.prime.router.azure.TokenFunction.kt</ID>
    <ID>NewLineAtEndOfFile:TokenFunctionTests.kt$gov.cdc.prime.router.azure.TokenFunctionTests.kt</ID>
    <ID>NewLineAtEndOfFile:Translator.kt$gov.cdc.prime.router.Translator.kt</ID>
    <ID>NewLineAtEndOfFile:TranslatorConfiguration.kt$gov.cdc.prime.router.TranslatorConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:TranslatorTests.kt$gov.cdc.prime.router.TranslatorTests.kt</ID>
    <ID>NewLineAtEndOfFile:TransportType.kt$gov.cdc.prime.router.TransportType.kt</ID>
    <ID>NewLineAtEndOfFile:USTimeZone.kt$gov.cdc.prime.router.USTimeZone.kt</ID>
    <ID>NewLineAtEndOfFile:ValueSet.kt$gov.cdc.prime.router.ValueSet.kt</ID>
    <ID>NewLineAtEndOfFile:WatersAuthTests.kt$gov.cdc.prime.router.cli.tests.WatersAuthTests.kt</ID>
    <ID>NewLineAtEndOfFile:WorkflowEngine.kt$gov.cdc.prime.router.azure.WorkflowEngine.kt</ID>
    <ID>NewLineAtEndOfFile:WorkflowEngineTests.kt$gov.cdc.prime.router.azure.WorkflowEngineTests.kt</ID>
    <ID>NewLineAtEndOfFile:main.kt$gov.cdc.prime.router.cli.main.kt</ID>
    <ID>PrintStackTrace:FTPSTransport.kt$FTPSTransport.Companion$e</ID>
    <ID>ReturnCount:Authentication.kt$OktaAuthenticationVerifier$override fun checkClaims( accessToken: String, minimumLevel: PrincipalLevel, organizationName: String?, oktaSender: Boolean ): AuthenticatedClaims?</ID>
    <ID>ReturnCount:CheckFunction.kt$CheckFunction$ @FunctionName("check") fun run( @HttpTrigger( name = "check", methods = [HttpMethod.GET, HttpMethod.POST], authLevel = AuthorizationLevel.FUNCTION, ) request: HttpRequestMessage&lt;String?>, ): HttpResponseMessage</ID>
    <ID>ReturnCount:CheckFunction.kt$CheckFunction$ private fun testTransport(receiver: Receiver, sftpFile: SftpFile?, responseBody: MutableList&lt;String>): Boolean</ID>
    <ID>ReturnCount:CompareData.kt$CompareCsvData$ private fun getCsvColumnIndex(element: Element?, expectedHeaders: List&lt;String>?): Int</ID>
    <ID>ReturnCount:CovidResultMetaDataFunction.kt$CovidResultMetaDataFunction$private fun saveCovidResultMetaDataForSingleReport( reportId: UUID, context: ExecutionContext, request: HttpRequestMessage&lt;String?> ): HttpResponseMessage</ID>
    <ID>ReturnCount:CsvSerializer.kt$CsvSerializer$fun readExternal( schemaName: String, input: InputStream, sources: List&lt;Source>, destination: Receiver? = null, defaultValues: Map&lt;String, String> = emptyMap(), ): ReadResult</ID>
    <ID>ReturnCount:CsvSerializer.kt$CsvSerializer$fun useCsv(element: Element): String?</ID>
    <ID>ReturnCount:Element.kt$Element$ fun checkForError(formattedValue: String, format: String? = null): ResponseMessage?</ID>
    <ID>ReturnCount:Element.kt$Element$fun truncateIfNeeded(str: String): String</ID>
    <ID>ReturnCount:FakeReport.kt$FakeDataService$// table values work in a similar fashion to the valuesets, but are // more flexible and allow for more filtering. fun createFakeTableValue(element: Element): String</ID>
    <ID>ReturnCount:FileSettings.kt$FileSettings$override fun findOrganizationAndReceiver(fullName: String): Pair&lt;Organization, Receiver>?</ID>
    <ID>ReturnCount:HistoryFunctions.kt$BaseHistoryFunction$ fun checkAuthenticated(request: HttpRequestMessage&lt;String?>, context: ExecutionContext): AuthClaims?</ID>
    <ID>ReturnCount:HistoryFunctions.kt$BaseHistoryFunction$fun getReportById( request: HttpRequestMessage&lt;String?>, reportIdIn: String, context: ExecutionContext ): HttpResponseMessage</ID>
    <ID>ReturnCount:Hl7Serializer.kt$Hl7Serializer$ fun convertMessageToMap(message: String, schema: Schema): RowResult</ID>
    <ID>ReturnCount:Hl7Serializer.kt$Hl7Serializer$ internal fun getSchoolId(report: Report, row: Int, rawFacilityName: String): String?</ID>
    <ID>ReturnCount:Hl7Tests.kt$BadHl7$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:HttpUtilities.kt$HttpUtilities.Companion$ fun payloadSizeCheck(request: HttpRequestMessage&lt;String?>): Pair&lt;HttpStatus, String></ID>
    <ID>ReturnCount:LookupTable.kt$LookupTable$ fun filter( filterColumn: String, filterValue: String, selectColumn: String, ignoreCase: Boolean = true ): List&lt;String></ID>
    <ID>ReturnCount:LookupTable.kt$LookupTable$ fun lookupPrefixValue( indexColumn: String, indexValue: String, lookupColumn: String, ignoreCase: Boolean = true ): String?</ID>
    <ID>ReturnCount:LookupTable.kt$LookupTable$ fun lookupValue( indexColumn: String, indexValue: String, lookupColumn: String, ignoreCase: Boolean = true ): String?</ID>
    <ID>ReturnCount:LookupTable.kt$LookupTable$ fun lookupValues( indexValues: List&lt;Pair&lt;String, String>>, lookupColumn: String, ignoreCase: Boolean = true ): String?</ID>
    <ID>ReturnCount:Mappers.kt$HashMapper$override fun apply(element: Element, args: List&lt;String>, values: List&lt;ElementAndValue>): String?</ID>
    <ID>ReturnCount:Mappers.kt$LIVDLookupMapper.Companion$ private fun lookupByDeviceId( element: Element, deviceId: String, filters: Map&lt;String, String> ): String?</ID>
    <ID>ReturnCount:Mappers.kt$MiddleInitialMapper$override fun apply(element: Element, args: List&lt;String>, values: List&lt;ElementAndValue>): String?</ID>
    <ID>ReturnCount:Mappers.kt$NullDateValidator$override fun apply(element: Element, args: List&lt;String>, values: List&lt;ElementAndValue>): String</ID>
    <ID>ReturnCount:OktaAuthentication.kt$OktaAuthentication$fun checkAccess( request: HttpRequestMessage&lt;String?>, organizationName: String = "", oktaSender: Boolean = false, block: (AuthenticatedClaims) -> HttpResponseMessage ): HttpResponseMessage</ID>
    <ID>ReturnCount:OktaCommands.kt$OktaCommand.Companion$fun isValidToken(oktaApp: OktaApp, accessTokenFile: AccessTokenFile): Boolean</ID>
    <ID>ReturnCount:Receiver.kt$Receiver$ fun consistencyErrorMessage(metadata: Metadata): String?</ID>
    <ID>ReturnCount:RedoxTransport.kt$RedoxTransport$override fun send( transportType: TransportType, header: WorkflowEngine.Header, sentReportId: ReportId, retryItems: RetryItems?, context: ExecutionContext, actionHistory: ActionHistory, ): RetryItems?</ID>
    <ID>ReturnCount:Report.kt$Report$fun getStringByHl7Field(row: Int, hl7Field: String, maxLength: Int? = null): String?</ID>
    <ID>ReturnCount:ReportFunction.kt$ReportFunction$ @FunctionName("reports") @StorageAccount("AzureWebJobsStorage") fun run( @HttpTrigger( name = "req", methods = [HttpMethod.POST], authLevel = AuthorizationLevel.FUNCTION ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>ReturnCount:ReportFunction.kt$ReportFunction$ @FunctionName("waters") @StorageAccount("AzureWebJobsStorage") fun report( @HttpTrigger( name = "waters", methods = [HttpMethod.POST], authLevel = AuthorizationLevel.ANONYMOUS ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>ReturnCount:ReportFunction.kt$ReportFunction$private fun validateRequest(engine: WorkflowEngine, request: HttpRequestMessage&lt;String?>): ValidatedRequest</ID>
    <ID>ReturnCount:RequeueFunction.kt$RequeueFunction$fun doResend( request: HttpRequestMessage&lt;String?>, workflowEngine: WorkflowEngine, msgs: MutableList&lt;String>, ): HttpResponseMessage</ID>
    <ID>ReturnCount:Scope.kt$Scope.Companion$fun isValidScope(scope: String, expectedSender: Sender): Boolean</ID>
    <ID>ReturnCount:SenderUtilsCommand.kt$AddPublicKey$override fun run()</ID>
    <ID>ReturnCount:SettingCommands.kt$SettingCommand$fun toYaml(output: String, settingType: SettingType): String</ID>
    <ID>ReturnCount:SettingsFacade.kt$SettingsFacade$ private fun &lt;T : SettingAPI> validateAndNormalize( json: String, clazz: Class&lt;T>, name: String, organizationName: String? = null, ): Triple&lt;Boolean, String?, JSONB?></ID>
    <ID>ReturnCount:SettingsTest.kt$SettingsTest$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$BadSftp$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$Hl7Null$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$InternationalContent$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$Merge$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$Ping$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$QualityFilter$ fun checkJsonItemCountForReceiver(receiver: Receiver, expectedCount: Int, json: String): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$SantaClaus$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$Strac$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$TooBig$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$TooManyCols$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TestReportStream.kt$Waters$override suspend fun run(environment: Environment, options: CoolTestOptions): Boolean</ID>
    <ID>ReturnCount:TokenAuthentication.kt$FindSenderKeyInSettings$override fun resolveSigningKey(jwsHeader: JwsHeader&lt;*>?, claims: Claims): Key?</ID>
    <ID>ReturnCount:TokenAuthentication.kt$TokenAuthentication$ fun checkAccessToken(accessToken: String, desiredScope: String, lookup: ReportStreamSecretFinder): Claims?</ID>
    <ID>ReturnCount:TokenAuthentication.kt$TokenAuthentication$ fun checkSenderToken( jwsString: String, senderPublicKeyFinder: SigningKeyResolverAdapter, actionHistory: ActionHistory? = null, ): Boolean</ID>
    <ID>ReturnCount:TokenAuthentication.kt$TokenAuthentication$fun checkAccessToken(request: HttpRequestMessage&lt;String?>, desiredScope: String): Claims?</ID>
    <ID>ReturnCount:TokenFunction.kt$TokenFunction$ @FunctionName("token") @StorageAccount("AzureWebJobsStorage") fun report( @HttpTrigger( name = "token", methods = [HttpMethod.POST], authLevel = AuthorizationLevel.ANONYMOUS ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>ReturnCount:TokenFunctionTests.kt$MockSettings$override fun findOrganizationAndReceiver(fullName: String): Pair&lt;Organization, Receiver>?</ID>
    <ID>ReturnCount:Translator.kt$Translator$fun translate( input: Report, toReceiver: String, defaultValues: DefaultValues = emptyMap() ): Pair&lt;Report, Receiver>?</ID>
    <ID>SpreadOperator:FakeReport.kt$FakeDataService$(*possibleValues)</ID>
    <ID>SpreadOperator:JurisdictionalFilters.kt$HasValidDataFor$(*selection.toArray())</ID>
    <ID>SwallowedException:CompareData.kt$CompareHl7Data$e: NoSuchElementException</ID>
    <ID>SwallowedException:Element.kt$Element$ex: Exception</ID>
    <ID>SwallowedException:EmailEngineFunction.kt$EmailScheduleEngine$ex: IOException</ID>
    <ID>SwallowedException:EmailEngineFunction.kt$EmailScheduleEngine$ex: Throwable</ID>
    <ID>SwallowedException:Environment.kt$Environment.Companion$e: IllegalArgumentException</ID>
    <ID>SwallowedException:FTPSTransport.kt$FTPSTransport.Companion$f: IOException</ID>
    <ID>SwallowedException:HistoryFunctions.kt$BaseHistoryFunction$ex: Exception</ID>
    <ID>SwallowedException:Hl7Serializer.kt$Hl7Serializer$e: Exception</ID>
    <ID>SwallowedException:Hl7Serializer.kt$Hl7Serializer$e: IllegalStateException</ID>
    <ID>SwallowedException:Hl7Tests.kt$BadHl7$e: IOException</ID>
    <ID>SwallowedException:Hl7Tests.kt$BadHl7$e: NullPointerException</ID>
    <ID>SwallowedException:HttpUtilities.kt$HttpUtilities.Companion$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableActivateCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableActivateCommand$e: LookupTableEndpointUtilities.Companion.TableNotFoundException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableCreateCommand$e: Exception</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableCreateCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableDiffCommand$e: Exception</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableDiffCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableDiffCommand$e: LookupTableEndpointUtilities.Companion.TableNotFoundException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableEndpointUtilities$e: Exception</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableEndpointUtilities$e: MismatchedInputException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableEndpointUtilities.Companion$e: Exception</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableEndpointUtilities.Companion$e: MismatchedInputException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableGetCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableGetCommand$e: LookupTableEndpointUtilities.Companion.TableNotFoundException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableListCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableLoadAllCommand$e: IOException</ID>
    <ID>SwallowedException:LookupTableCommands.kt$LookupTableLoadAllCommand$e: NoSuchFileException</ID>
    <ID>SwallowedException:LookupTableFunctions.kt$LookupTableFunctions$e: MismatchedInputException</ID>
    <ID>SwallowedException:Mappers.kt$NullDateValidator$ex: Exception</ID>
    <ID>SwallowedException:Mappers.kt$NullDateValidator$ex: IllegalArgumentException</ID>
    <ID>SwallowedException:OktaCommands.kt$OktaCommand.Companion$ex: Exception</ID>
    <ID>SwallowedException:Report.kt$Report.Format.Companion$e: IllegalArgumentException</ID>
    <ID>SwallowedException:ReportFunction.kt$ReportFunction$e: IllegalArgumentException</ID>
    <ID>SwallowedException:Scope.kt$Scope.Companion$e: IllegalArgumentException</ID>
    <ID>SwallowedException:SettingsFacade.kt$SettingsFacade$ex: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$BadCsv$e: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$CoolTest$e: NullPointerException</ID>
    <ID>SwallowedException:TestReportStream.kt$Garbage$e: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$InternationalContent$e: NullPointerException</ID>
    <ID>SwallowedException:TestReportStream.kt$Ping$e: NullPointerException</ID>
    <ID>SwallowedException:TestReportStream.kt$QualityFilter$e: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$Strac$e: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$TooBig$e: Exception</ID>
    <ID>SwallowedException:TestReportStream.kt$TooManyCols$e: Exception</ID>
    <ID>SwallowedException:WorkflowEngine.kt$WorkflowEngine$e: Exception</ID>
    <ID>ThrowsCount:LookupTableCommands.kt$LookupTableEndpointUtilities.Companion$ internal fun checkCommonErrorsFromResponse(result: Result&lt;FuelJson, FuelError>, response: Response)</ID>
    <ID>ThrowsCount:WorkflowEngine.kt$WorkflowEngine$ fun resendEvent( reportId: ReportId, receiver: Receiver, sendFailedOnly: Boolean, isTest: Boolean, msgs: MutableList&lt;String>, )</ID>
    <ID>TooGenericExceptionCaught:AS2Transport.kt$AS2Transport$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ActionHistory.kt$ActionHistory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BatchFunction.kt$BatchFunction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlobStoreTransport.kt$BlobStoreTransport$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:CheckFunction.kt$CheckFunction$ex: Throwable</ID>
    <ID>TooGenericExceptionCaught:CheckFunction.kt$CheckFunction$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:CovidResultMetaDataFunction.kt$CovidResultMetaDataFunction$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Element.kt$Element$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:EmailEngineFunction.kt$EmailScheduleEngine$ex: Throwable</ID>
    <ID>TooGenericExceptionCaught:EmailTransport.kt$EmailTransport$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:FTPSTransport.kt$FTPSTransport$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:FTPSTransport.kt$FTPSTransport.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FileSettings.kt$FileSettings$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HistoryFunctions.kt$BaseHistoryFunction$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:HistoryFunctions.kt$BaseHistoryFunction$ex: Throwable</ID>
    <ID>TooGenericExceptionCaught:Hl7Serializer.kt$Hl7Serializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LookupTableCommands.kt$LookupTableCreateCommand$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LookupTableCommands.kt$LookupTableDiffCommand$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LookupTableCommands.kt$LookupTableEndpointUtilities$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LookupTableCommands.kt$LookupTableEndpointUtilities.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LookupTableFunctions.kt$LookupTableFunctions$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Mappers.kt$NullDateValidator$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Metadata.kt$Metadata$e: Exception</ID>
    <ID>TooGenericExceptionCaught:OktaAuthentication.kt$OktaAuthentication$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:OktaCommands.kt$OktaCommand.Companion$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ProcessFunction.kt$ProcessFunction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RedoxTransport.kt$RedoxTransport$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:Report.kt$Report$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReportFunction.kt$ReportFunction$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:RequeueFunction.kt$RequeueFunction$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SendFunction.kt$SendFunction$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SettingsFacade.kt$SettingsFacade$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SftpTransport.kt$SftpTransport$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SftpTransport.kt$SftpTransport.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:TokenAuthentication.kt$TokenAuthentication$e: NullPointerException</ID>
    <ID>TooGenericExceptionCaught:TokenAuthentication.kt$TokenAuthentication$exc: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:WorkflowEngine.kt$WorkflowEngine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WorkflowEngine.kt$WorkflowEngine$ex: Exception</ID>
    <ID>TooGenericExceptionThrown:AzureCredentialService.kt$AzureCredentialService$throw Exception("Failed to save credentials for: $connectionId")</ID>
    <ID>TooGenericExceptionThrown:CheckFunction.kt$CheckFunction$throw Exception("File ${sftpFile.name} already exists on SFTP server. Aborting upload.")</ID>
    <ID>TooGenericExceptionThrown:EmailEngineFunction.kt$EmailScheduleEngine$throw Throwable("Error in validation of jwt token")</ID>
    <ID>TooGenericExceptionThrown:FTPSTransport.kt$FTPSTransport.Companion$throw Exception("Could not log into FTPS server with user $username")</ID>
    <ID>TooGenericExceptionThrown:FileSettings.kt$FileSettings$throw Exception("Error loading: $filePath", e)</ID>
    <ID>TooGenericExceptionThrown:HashicorpVaultCredentialService.kt$HashicorpVaultCredentialService$throw Exception("Failed to save credentials for: $connectionId")</ID>
    <ID>TooGenericExceptionThrown:HistoryFunctions.kt$BaseHistoryFunction$throw Throwable("Error in validation of jwt token")</ID>
    <ID>TooGenericExceptionThrown:Metadata.kt$Metadata$throw Exception("Error loading $catalog", e)</ID>
    <ID>TooGenericExceptionThrown:Metadata.kt$Metadata$throw Exception("Error loading schema catalog: $catalog", e)</ID>
    <ID>TooGenericExceptionThrown:Metadata.kt$Metadata$throw Exception("Error loading tables in '$filePath'", e)</ID>
    <ID>TooGenericExceptionThrown:Metadata.kt$Metadata$throw Exception("Error parsing '${file.name}'", e)</ID>
    <ID>TooGenericExceptionThrown:Metadata.kt$Metadata$throw Exception("Error reading '${file.name}'", e)</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception( "Cannot send $reportId. Its already scheduled to ${header.task.nextAction}" + " at ${header.task.nextActionAt}" )</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("Cannot send $reportId. It is not associated with receiver ${receiver.fullName}")</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("Cannot send $reportId. Its next action is ${reportFile.nextAction}")</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("Cannot send $reportId. Its not in the blob store.")</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("Cannot send ${reportFile.reportId}. Its next action is ${reportFile.nextAction}")</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("No such organization ${receiver.organizationName}")</ID>
    <ID>TooGenericExceptionThrown:WorkflowEngine.kt$WorkflowEngine$throw Exception("SendFailed option only applies to REDOX reports. This report is ${reportFile.bodyFormat}")</ID>
    <ID>TooManyFunctions:ActionHistory.kt$ActionHistory</ID>
    <ID>TooManyFunctions:DatabaseAccess.kt$DatabaseAccess : Logging</ID>
    <ID>TooManyFunctions:Element.kt$Element</ID>
    <ID>TooManyFunctions:EmailEngineFunction.kt$EmailScheduleEngine</ID>
    <ID>TooManyFunctions:HistoryFunctions.kt$ReportView$Builder</ID>
    <ID>TooManyFunctions:Hl7Serializer.kt$Hl7Serializer : Logging</ID>
    <ID>TooManyFunctions:HttpUtilities.kt$HttpUtilities$Companion : Logging</ID>
    <ID>TooManyFunctions:LookupTable.kt$LookupTable : Iterable</ID>
    <ID>TooManyFunctions:Metadata.kt$Metadata : Logging</ID>
    <ID>TooManyFunctions:Report.kt$Report : Logging</ID>
    <ID>TooManyFunctions:Report.kt$Report$Companion</ID>
    <ID>TooManyFunctions:SettingCommands.kt$SettingCommand : CliktCommand</ID>
    <ID>TooManyFunctions:SettingsFacade.kt$SettingsFacade : SettingsProvider</ID>
    <ID>TooManyFunctions:WorkflowEngine.kt$WorkflowEngine</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$// These constants match how PRIME Okta subscription is configured const val oktaGroupPrefix = "DH"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val envVariableForOktaBaseUrl = "OKTA_baseUrl"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val oktaAdminGroupSuffix = "Admins"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val oktaMembershipClaim = "organization"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val oktaSenderGroupPrefix = "DHSender_"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val oktaSubjectClaim = "sub"</ID>
    <ID>TopLevelPropertyNaming:Authentication.kt$const val oktaSystemAdminGroup = "DHPrimeAdmins"</ID>
    <ID>TopLevelPropertyNaming:BatchFunction.kt$const val batch = "batch"</ID>
    <ID>TopLevelPropertyNaming:BatchFunction.kt$const val defaultBatchSize = 100</ID>
    <ID>TopLevelPropertyNaming:BlobAccess.kt$const val defaultBlobContainerName = "reports"</ID>
    <ID>TopLevelPropertyNaming:DatabaseAccess.kt$const val databaseVariable = "POSTGRES_URL"</ID>
    <ID>TopLevelPropertyNaming:DatabaseAccess.kt$const val passwordVariable = "POSTGRES_PASSWORD"</ID>
    <ID>TopLevelPropertyNaming:DatabaseAccess.kt$const val userVariable = "POSTGRES_USER"</ID>
    <ID>TopLevelPropertyNaming:Event.kt$/** * A event represents a function call, either one that has just happened or on that will happen in the future. * Events are sent to queues as messages or stored in a DB as columns of the Task table. */ const val messageDelimiter = "&amp;"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$/** * Implements a PKCE OAUTH2 authorization workflow with the HHS-PRIME Okta account. A browser is launched * for the user to enter credentials. A local server is setup to handle the Oauth2 redirect and to capture * the authorization code. * * Based on Okta article https://developer.okta.com/blog/2018/12/13/oauth-2-for-native-and-mobile-apps */ private const val oktaBaseUrl = "https://hhs-prime.okta.com"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val localPrimeFolder = ".prime"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val localTokenFileName = "accessToken.json"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val oktaAuthorizePath = "/oauth2/default/v1/authorize" // Default authorization server</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val oktaScope = "openid"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val oktaTokenPath = "/oauth2/default/v1/token"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val oktaUserInfoPath = "/oauth2/default/v1/userinfo"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val redirectHost = "http://localhost"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val redirectPath = "/callback"</ID>
    <ID>TopLevelPropertyNaming:OktaCommands.kt$private const val redirectPort = 9988</ID>
    <ID>TopLevelPropertyNaming:ProcessFunction.kt$const val azureFunctionName = "process"</ID>
    <ID>TopLevelPropertyNaming:ProcessFunction.kt$const val azureQueueName = "process"</ID>
    <ID>TopLevelPropertyNaming:SendFunction.kt$/** * Azure Functions with HTTP Trigger. Write to blob. */ const val dataRetentionDays = 7L</ID>
    <ID>TopLevelPropertyNaming:SendFunction.kt$const val maxDurationValue = 120L</ID>
    <ID>TopLevelPropertyNaming:SendFunction.kt$const val maxRetryCount = 4</ID>
    <ID>TopLevelPropertyNaming:SendFunction.kt$const val send = "send"</ID>
    <ID>TopLevelPropertyNaming:SettingCommands.kt$private const val apiPath = "/api/settings"</ID>
    <ID>TopLevelPropertyNaming:SettingCommands.kt$private const val dummyAccessToken = "dummy"</ID>
    <ID>TopLevelPropertyNaming:SettingCommands.kt$private const val jsonMimeType = "application/json"</ID>
    <ID>TopLevelPropertyNaming:SettingsUtilities.kt$private const val apiPath = "/api/settings"</ID>
    <ID>TopLevelPropertyNaming:SettingsUtilities.kt$private const val jsonMimeType = "application/json"</ID>
    <ID>UndocumentedPublicClass:Authentication.kt$AuthenticatedClaims</ID>
    <ID>UndocumentedPublicClass:Authentication.kt$AuthenticationVerifier</ID>
    <ID>UndocumentedPublicClass:Authentication.kt$OktaAuthenticationVerifier : AuthenticationVerifier</ID>
    <ID>UndocumentedPublicClass:Authentication.kt$PrincipalLevel</ID>
    <ID>UndocumentedPublicClass:Authentication.kt$TestAuthenticationVerifier : AuthenticationVerifier</ID>
    <ID>UndocumentedPublicClass:AuthenticationStrategy.kt$AuthenticationStrategy : Logging</ID>
    <ID>UndocumentedPublicClass:AuthenticationStrategy.kt$AuthenticationStrategy$Types</ID>
    <ID>UndocumentedPublicClass:BlobAccess.kt$BlobAccess : Logging</ID>
    <ID>UndocumentedPublicClass:BlobAccess.kt$BlobAccess$BlobInfo</ID>
    <ID>UndocumentedPublicClass:BlobStoreTransport.kt$BlobStoreTransport : ITransport</ID>
    <ID>UndocumentedPublicClass:CheckFunction.kt$CheckFunction : Logging</ID>
    <ID>UndocumentedPublicClass:CheckFunction.kt$CheckFunction$SftpFile</ID>
    <ID>UndocumentedPublicClass:CheckFunction.kt$CheckFunction$TestFileFilter : RemoteResourceFilter</ID>
    <ID>UndocumentedPublicClass:CovidResultMetaDataFunction.kt$CovidResultMetaDataFunction : Logging</ID>
    <ID>UndocumentedPublicClass:Credential.kt$Credential</ID>
    <ID>UndocumentedPublicClass:Credential.kt$SftpCredential</ID>
    <ID>UndocumentedPublicClass:Credential.kt$UserPemCredential : CredentialSftpCredential</ID>
    <ID>UndocumentedPublicClass:CredentialManagement.kt$CredentialHelper</ID>
    <ID>UndocumentedPublicClass:CredentialManagement.kt$CredentialManagement</ID>
    <ID>UndocumentedPublicClass:CredentialService.kt$CredentialRequestReason</ID>
    <ID>UndocumentedPublicClass:CredentialService.kt$CredentialService : Logging</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$CredentialConfig : OptionGroup</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$CredentialsCli : CredentialManagementCliktCommand</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$UserJksCredentialOptions : CredentialConfig</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$UserPassCredentialOptions : CredentialConfig</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$UserPemCredentialOptions : CredentialConfig</ID>
    <ID>UndocumentedPublicClass:CredentialsCli.kt$UserPpkCredentialOptions : CredentialConfig</ID>
    <ID>UndocumentedPublicClass:CsvComparer.kt$CsvComparer</ID>
    <ID>UndocumentedPublicClass:CsvComparer.kt$HeaderComparison</ID>
    <ID>UndocumentedPublicClass:DatabaseJtiCache.kt$DatabaseJtiCache : JtiCache</ID>
    <ID>UndocumentedPublicClass:DocumentationFactory.kt$DocumentationFactory</ID>
    <ID>UndocumentedPublicClass:Element.kt$AltValueNotDefinedException : IllegalStateException</ID>
    <ID>UndocumentedPublicClass:Element.kt$Element$CsvField</ID>
    <ID>UndocumentedPublicClass:Element.kt$Element$EIFields</ID>
    <ID>UndocumentedPublicClass:Element.kt$Element$HDFields</ID>
    <ID>UndocumentedPublicClass:Element.kt$Element$SubValue</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidCodeMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidDateMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidHL7Message : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidParamMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidPhoneMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidPostalMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidReportMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$InvalidTranslationMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$MissingFieldMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$UnsupportedEIMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ElementErrors.kt$UnsupportedHDMessage : ResponseMessage</ID>
    <ID>UndocumentedPublicClass:EmailEngineFunction.kt$EmailSchedule</ID>
    <ID>UndocumentedPublicClass:EmailEngineFunction.kt$EmailScheduleEngine</ID>
    <ID>UndocumentedPublicClass:EmailTransport.kt$EmailTransport : ITransport</ID>
    <ID>UndocumentedPublicClass:Event.kt$Event</ID>
    <ID>UndocumentedPublicClass:Event.kt$Event$EventAction</ID>
    <ID>UndocumentedPublicClass:Event.kt$ReceiverEvent : Event</ID>
    <ID>UndocumentedPublicClass:Event.kt$ReportEvent : Event</ID>
    <ID>UndocumentedPublicClass:FakeReport.kt$FakeDataService</ID>
    <ID>UndocumentedPublicClass:FakeReport.kt$FakeReport</ID>
    <ID>UndocumentedPublicClass:FakeReport.kt$FakeReport$RowContext</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$CreatedDate : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$FileNameTemplate</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$FileUuid : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$Literal : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$ProcessingModeCode : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$ReceivingOrganization : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$RegexReplace : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileNameTemplate.kt$SchemaBaseName : FileNameElement</ID>
    <ID>UndocumentedPublicClass:FileSettings.kt$FileSettings : SettingsProvider</ID>
    <ID>UndocumentedPublicClass:FileUtilities.kt$FileUtilities</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$Action</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$Action$Builder</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$BaseHistoryFunction : Logging</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$BaseHistoryFunction$AuthClaims</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$Facility</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$Facility$Builder</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$FileReturn</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$GetFacilitiesByReportId : BaseHistoryFunction</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$GetReportById : BaseHistoryFunction</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$GetReports : BaseHistoryFunction</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$ReportView</ID>
    <ID>UndocumentedPublicClass:HistoryFunctions.kt$ReportView$Builder</ID>
    <ID>UndocumentedPublicClass:Hl7Serializer.kt$Hl7Serializer : Logging</ID>
    <ID>UndocumentedPublicClass:Hl7Serializer.kt$Hl7Serializer$Hl7Mapping</ID>
    <ID>UndocumentedPublicClass:Hl7Serializer.kt$Hl7Serializer$RowResult</ID>
    <ID>UndocumentedPublicClass:HttpUtilities.kt$HttpUtilities</ID>
    <ID>UndocumentedPublicClass:ITransport.kt$ITransport</ID>
    <ID>UndocumentedPublicClass:JurisdictionalFilters.kt$JurisdictionalFilters : Logging</ID>
    <ID>UndocumentedPublicClass:Jwk.kt$JwkSet</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$CoalesceMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$DateTimeOffsetMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$ElementAndValue</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$Mappers</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$MiddleInitialMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$SplitByCommaMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$SplitMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$StripNonNumericDataMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$StripNumericDataMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$StripPhoneFormattingMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$TimestampMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$TrimBlanksMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:Mappers.kt$ZipCodeToCountyMapper : Mapper</ID>
    <ID>UndocumentedPublicClass:MemoryJtiCache.kt$MemoryJtiCache : JtiCache</ID>
    <ID>UndocumentedPublicClass:OktaAuthentication.kt$OktaAuthentication : Logging</ID>
    <ID>UndocumentedPublicClass:OktaCommands.kt$OktaCommand$AccessTokenFile</ID>
    <ID>UndocumentedPublicClass:OktaCommands.kt$OktaCommand$OktaApp</ID>
    <ID>UndocumentedPublicClass:Organization.kt$Organization$Jurisdiction</ID>
    <ID>UndocumentedPublicClass:ProcessDataCommands.kt$InputSource</ID>
    <ID>UndocumentedPublicClass:ProcessDataCommands.kt$InputSource$DirSource : InputSource</ID>
    <ID>UndocumentedPublicClass:ProcessDataCommands.kt$InputSource$FakeSource : InputSource</ID>
    <ID>UndocumentedPublicClass:ProcessDataCommands.kt$InputSource$FileSource : InputSource</ID>
    <ID>UndocumentedPublicClass:ProcessDataCommands.kt$InputSource$ListOfFilesSource : InputSource</ID>
    <ID>UndocumentedPublicClass:Receiver.kt$Receiver$BatchOperation</ID>
    <ID>UndocumentedPublicClass:RedoxSerializer.kt$RedoxSerializer</ID>
    <ID>UndocumentedPublicClass:RedoxTransport.kt$RedoxTransport : ITransportSecretManagement</ID>
    <ID>UndocumentedPublicClass:RedoxTransport.kt$RedoxTransport$ResultStatus</ID>
    <ID>UndocumentedPublicClass:RedoxTransport.kt$RedoxTransport$SendResult</ID>
    <ID>UndocumentedPublicClass:Report.kt$Options</ID>
    <ID>UndocumentedPublicClass:Report.kt$Report$Format</ID>
    <ID>UndocumentedPublicClass:ReportFunction.kt$ReportFunction$ValidatedRequest</ID>
    <ID>UndocumentedPublicClass:ReportStreamSecretFinder.kt$FindReportStreamSecretInVault : ReportStreamSecretFinder</ID>
    <ID>UndocumentedPublicClass:ReportStreamSecretFinder.kt$ReportStreamSecretFinder</ID>
    <ID>UndocumentedPublicClass:RequeueFunction.kt$RequeueFunction : Logging</ID>
    <ID>UndocumentedPublicClass:ResponseMessage.kt$ResponseMessage</ID>
    <ID>UndocumentedPublicClass:ResponseMessage.kt$ResponseMsgType</ID>
    <ID>UndocumentedPublicClass:RetryToken.kt$RetryToken</ID>
    <ID>UndocumentedPublicClass:SecretManagement.kt$SecretHelper</ID>
    <ID>UndocumentedPublicClass:SecretManagement.kt$SecretManagement</ID>
    <ID>UndocumentedPublicClass:SecretService.kt$SecretService</ID>
    <ID>UndocumentedPublicClass:SendFunction.kt$SendFunction</ID>
    <ID>UndocumentedPublicClass:Sender.kt$Sender$Format</ID>
    <ID>UndocumentedPublicClass:SenderUtils.kt$SenderUtils</ID>
    <ID>UndocumentedPublicClass:SenderUtilsCommand.kt$AddPublicKey : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SenderUtilsCommand.kt$TokenUrl : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$DeleteOrganizationSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$DeleteReceiverSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$DeleteSenderSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$GetMultipleSettings : SettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$GetOrganizationSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$GetReceiverSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$GetSenderSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$ListOrganizationSetting : SingleSettingCommandNoSettingName</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$ListReceiverSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$ListSenderSetting : SingleSettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$PutMultipleSettings : SettingCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$PutOrganizationSetting : SingleSettingWithInputCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$PutReceiverSetting : SingleSettingWithInputCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$PutSenderSetting : SingleSettingWithInputCommand</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$SettingCommand$Operation</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$SettingCommand$SettingType</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$SingleSettingCommand : SingleSettingCommandNoSettingName</ID>
    <ID>UndocumentedPublicClass:SettingCommands.kt$SingleSettingWithInputCommand : SingleSettingCommandNoSettingName</ID>
    <ID>UndocumentedPublicClass:SettingsFacade.kt$OrganizationAPI : OrganizationSettingAPI</ID>
    <ID>UndocumentedPublicClass:SettingsFacade.kt$ReceiverAPI : ReceiverSettingAPI</ID>
    <ID>UndocumentedPublicClass:SettingsFacade.kt$SenderAPI : SenderSettingAPI</ID>
    <ID>UndocumentedPublicClass:SettingsFacade.kt$SettingAPI</ID>
    <ID>UndocumentedPublicClass:SettingsFacade.kt$SettingsFacade$AccessResult</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$GetOneOrganization : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$GetOneReceiver : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$GetOneSender : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$GetOrganizations : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$UpdateOrganization : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$UpdateReceiver : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SettingsFunctions.kt$UpdateSender : BaseFunction</ID>
    <ID>UndocumentedPublicClass:SftpTransport.kt$SftpTransport : ITransportLogging</ID>
    <ID>UndocumentedPublicClass:Source.kt$ClientSource : Source</ID>
    <ID>UndocumentedPublicClass:Source.kt$FileSource : Source</ID>
    <ID>UndocumentedPublicClass:Source.kt$ReportSource : Source</ID>
    <ID>UndocumentedPublicClass:Source.kt$TestSource : Source</ID>
    <ID>UndocumentedPublicClass:TokenFunction.kt$TokenFunction : Logging</ID>
    <ID>UndocumentedPublicClass:TranslatorConfiguration.kt$Hl7Configuration$OrderingFacilityName</ID>
    <ID>UndocumentedPublicClass:TranslatorConfiguration.kt$TranslatorConfiguration : TranslatorProperties</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$AS2TransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$BlobStoreTransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$EmailTransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$FtpsProtocol</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$NullTransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$RedoxTransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$SFTPTransportType : TransportType</ID>
    <ID>UndocumentedPublicClass:TransportType.kt$TransportType</ID>
    <ID>UndocumentedPublicClass:USTimeZone.kt$USTimeZone</ID>
    <ID>UndocumentedPublicClass:ValueSet.kt$ValueSet</ID>
    <ID>UndocumentedPublicClass:ValueSet.kt$ValueSet$SetSystem</ID>
    <ID>UndocumentedPublicClass:ValueSet.kt$ValueSet$Value</ID>
    <ID>UndocumentedPublicClass:main.kt$CompareCsvFiles : CliktCommand</ID>
    <ID>UndocumentedPublicClass:main.kt$GenerateDocs : CliktCommand</ID>
    <ID>UndocumentedPublicClass:main.kt$ListSchemas : CliktCommand</ID>
    <ID>UndocumentedPublicClass:main.kt$RouterCli : CliktCommand</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun prettyPrintDestinationJson( jsonGen: JsonGenerator, orgReceiver: Receiver, organization: Organization, sendingAt: OffsetDateTime?, countToPrint: Int, reportOptions: Options, reportId: ReportId )</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun queueMessages(workflowEngine: WorkflowEngine)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun setActionType(taskAction: TaskAction)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackActionParams(request: HttpRequestMessage&lt;String?>)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackActionRequestResponse(request: HttpRequestMessage&lt;String?>, response: HttpResponseMessage)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackActionResult(httpResponseMessage: HttpResponseMessage)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackEvent(event: Event)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackItemLineages(itemLineages: List&lt;ItemLineage>?)</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory$fun trackSentReport( receiver: Receiver, sentReportId: ReportId, fileName: String?, params: String, result: String, itemCount: Int )</ID>
    <ID>UndocumentedPublicFunction:ActionHistory.kt$ActionHistory.Companion$// TODO: Deprecated. Delete. WorkflowEngine.handleRecieverEvent pulls in each report individually. fun fetchReportFilesForReceiver( nextAction: TaskAction, at: OffsetDateTime?, receiver: Receiver, limit: Int, ctx: DSLContext, ): Map&lt;ReportId, ReportFile></ID>
    <ID>UndocumentedPublicFunction:AuthenticationStrategy.kt$AuthenticationStrategy.Types$// Returns an OktaAuthentication strategy if the authenticationType is "okta" fun authStrategy( authenticationType: String?, principalLevel: PrincipalLevel, workflowEngine: WorkflowEngine ): Any</ID>
    <ID>UndocumentedPublicFunction:BatchFunction.kt$BatchFunction$@FunctionName(batch) @StorageAccount("AzureWebJobsStorage") fun run( @QueueTrigger(name = "message", queueName = batch) message: String, context: ExecutionContext, )</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess$fun checkConnection(blobConnEnvVar: String = defaultConnEnvVar)</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess$fun copyBlob(fromBlobUrl: String, toBlobContainer: String, toBlobConnEnvVar: String): String</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess$fun deleteBlob(blobUrl: String)</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess$fun downloadBlob(blobUrl: String): ByteArray</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess$fun getBlobClient(blobUrl: String, blobConnEnvVar: String = defaultConnEnvVar): BlobClient</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess.Companion$fun hashBytes(type: String, input: ByteArray): ByteArray</ID>
    <ID>UndocumentedPublicFunction:BlobAccess.kt$BlobAccess.Companion$fun sha256Digest(input: ByteArray): ByteArray</ID>
    <ID>UndocumentedPublicFunction:CovidResultMetaDataFunction.kt$CovidResultMetaDataFunction$@FunctionName("save-covid-result-metadata") fun run( @HttpTrigger( name = "saveTestData", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.FUNCTION ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:Credential.kt$Credential$fun toJSON(): String</ID>
    <ID>UndocumentedPublicFunction:Credential.kt$Credential.Companion$fun fromJSON(json: String?): Credential?</ID>
    <ID>UndocumentedPublicFunction:CredentialManagement.kt$CredentialHelper.Companion$fun getCredentialService(): CredentialService</ID>
    <ID>UndocumentedPublicFunction:CredentialService.kt$CredentialService$fun fetchCredential(connectionId: String, callerId: String, reason: CredentialRequestReason): Credential?</ID>
    <ID>UndocumentedPublicFunction:CredentialService.kt$CredentialService$fun saveCredential(connectionId: String, credential: Credential, callerId: String)</ID>
    <ID>UndocumentedPublicFunction:CsvComparer.kt$CsvComparer$fun compareFiles(): Boolean</ID>
    <ID>UndocumentedPublicFunction:CsvComparer.kt$CsvComparer$fun compareKeysOfMaps(fileOne: Map&lt;String, Any?>, fileTwo: Map&lt;String, Any?>): HeaderComparison</ID>
    <ID>UndocumentedPublicFunction:CsvComparer.kt$CsvComparer$fun compareLinesOfMaps( expected: Map&lt;String, Any?>, actual: Map&lt;String, Any?>, headerRow: List&lt;String>? = null ): Map&lt;String, List&lt;String>></ID>
    <ID>UndocumentedPublicFunction:CsvComparer.kt$CsvComparer$fun convertFileToMap( lines: List&lt;String>, recordId: String = "Patient_ID", skipHeader: Boolean = true, delimiter: String = "," ): Map&lt;String, Any?></ID>
    <ID>UndocumentedPublicFunction:CsvComparer.kt$HeaderComparison$fun hasErrors(): Boolean</ID>
    <ID>UndocumentedPublicFunction:CsvSerializer.kt$CsvSerializer$fun readExternal( schemaName: String, input: InputStream, sources: List&lt;Source>, destination: Receiver? = null, defaultValues: Map&lt;String, String> = emptyMap(), ): ReadResult</ID>
    <ID>UndocumentedPublicFunction:CsvSerializer.kt$CsvSerializer$fun readExternal(schemaName: String, input: InputStream, source: Source): ReadResult</ID>
    <ID>UndocumentedPublicFunction:CsvSerializer.kt$CsvSerializer$fun write(report: Report, output: OutputStream)</ID>
    <ID>UndocumentedPublicFunction:CsvSerializer.kt$CsvSerializer$fun writeInternal(report: Report, output: OutputStream)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun checkConnection()</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun checkReportExists(reportId: ReportId, txn: DataAccessTransaction): Boolean</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun deactivateSetting(settingId: Int, txn: DataAccessTransaction)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun deactivateSettingAndChildren(settingId: Int, txn: DataAccessTransaction)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun deleteEmailSchedule(id: Int, txn: DataAccessTransaction? = null)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun deleteExpiredJtis(txn: DataAccessTransaction)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun deleteTestDataForReportId(reportId: UUID, txn: DataAccessTransaction)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchAllInternalReports( createdDateTime: OffsetDateTime? = null, txn: DataAccessTransaction? = null ): List&lt;ReportFile></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchChildReports( parentReportId: UUID, txn: DataAccessTransaction? = null, ): List&lt;ReportId></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchDownloadableReportFiles( since: OffsetDateTime?, orgName: String, txn: DataAccessTransaction? = null, ): List&lt;ReportFile></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchJti(jti: String, txn: DataAccessTransaction): JtiCache?</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchSetting( type: SettingType, name: String, organizationName: String, txn: DataAccessTransaction ): Setting?</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchSettings( type: SettingType, organizationId: Int, txn: DataAccessTransaction ): List&lt;Setting></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchSettings(type: SettingType, txn: DataAccessTransaction): List&lt;Setting></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun fetchTask(reportId: ReportId): Task</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun getFacilitiesForDownloadableReport( reportId: ReportId, txn: DataAccessTransaction? = null ): List&lt;Facility></ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun insertEmailSchedule(body: String?, user: String, txn: DataAccessTransaction? = null): Int?</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun insertJti(jti: String, expiresAt: OffsetDateTime? = null, txn: DataAccessTransaction)</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun insertSetting(setting: Setting, txn: DataAccessTransaction): Int</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun updateOrganizationId( currentOrganizationId: Int, newOrganizationId: Int, txn: DataAccessTransaction )</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess$fun updateTask( reportId: ReportId, nextAction: TaskAction, nextActionAt: OffsetDateTime?, retryToken: String?, finishedField: Field&lt;OffsetDateTime>, txn: DataAccessTransaction? )</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess.Companion$fun createTask( report: Report, bodyFormat: String, bodyUrl: String, nextAction: Event, ): Task</ID>
    <ID>UndocumentedPublicFunction:DatabaseAccess.kt$DatabaseAccess.Companion$fun createTaskRecord( report: Report, bodyFormat: String, bodyUrl: String, nextAction: Event, ): TaskRecord</ID>
    <ID>UndocumentedPublicFunction:DocumentationFactory.kt$DocumentationFactory$// gets the documentation fun getSchemaDocumentation(schema: Schema): String</ID>
    <ID>UndocumentedPublicFunction:DocumentationFactory.kt$DocumentationFactory$fun getElementDocumentation(element: Element): String</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun defaultValue(defaultValues: DefaultValues): String</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun inheritFrom(baseElement: Element): Element</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun nameContains(substring: String): Boolean</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun toAltCode(altDisplay: String): String?</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun toAltDisplay(code: String): String?</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun toNormalized(subValues: List&lt;SubValue>): String</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element$fun truncateIfNeeded(str: String): String</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element.Cardinality$fun toFormatted(): String</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element.Companion$fun csvFields(name: String, format: String? = null): List&lt;CsvField></ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element.Companion$fun parseEI(value: String): EIFields</ID>
    <ID>UndocumentedPublicFunction:Element.kt$Element.Companion$fun parseHD(value: String, maximumLength: Int? = null): HDFields</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidCodeMessage.Companion$fun new(formattedValue: String, fieldMapping: String, format: String?): InvalidCodeMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidDateMessage.Companion$fun new(formattedValue: String, fieldMapping: String, format: String?): InvalidDateMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidHL7Message.Companion$fun new(message: String): InvalidHL7Message</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidParamMessage.Companion$fun new(message: String): InvalidParamMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidPhoneMessage.Companion$fun new(formattedValue: String, fieldMapping: String): InvalidPhoneMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidPostalMessage.Companion$fun new(formattedValue: String, fieldMapping: String, format: String?): InvalidPostalMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidReportMessage.Companion$fun new(message: String): InvalidReportMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$InvalidTranslationMessage.Companion$fun new(message: String): InvalidTranslationMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$MissingFieldMessage.Companion$fun new(fieldMapping: String): MissingFieldMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$UnsupportedEIMessage.Companion$fun new(): UnsupportedEIMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$UnsupportedEIMessage.Companion$fun new(formattedValue: String, fieldMapping: String): UnsupportedEIMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$UnsupportedHDMessage.Companion$fun new(): UnsupportedHDMessage</ID>
    <ID>UndocumentedPublicFunction:ElementErrors.kt$UnsupportedHDMessage.Companion$fun new(formattedValue: String, fieldMapping: String): UnsupportedHDMessage</ID>
    <ID>UndocumentedPublicFunction:EmailTransport.kt$EmailTransport$fun buildContent(header: WorkflowEngine.Header): Content</ID>
    <ID>UndocumentedPublicFunction:EmailTransport.kt$EmailTransport$fun buildMail(content: Content, emailTransport: EmailTransportType): Mail</ID>
    <ID>UndocumentedPublicFunction:EmailTransport.kt$EmailTransport$fun getTemplateEngine(): TemplateEngine</ID>
    <ID>UndocumentedPublicFunction:EmailTransport.kt$EmailTransport$fun getTemplateFromAttributes(htmlContent: String, attr: Map&lt;String, Any>): String</ID>
    <ID>UndocumentedPublicFunction:Event.kt$Event$abstract fun toQueueMessage(): String</ID>
    <ID>UndocumentedPublicFunction:Event.kt$Event.Companion$fun parseQueueMessage(event: String): Event</ID>
    <ID>UndocumentedPublicFunction:Event.kt$Event.EventAction$fun toQueueName(): String?</ID>
    <ID>UndocumentedPublicFunction:Event.kt$Event.EventAction$fun toTaskAction(): TaskAction</ID>
    <ID>UndocumentedPublicFunction:Event.kt$Event.EventAction.Companion$fun parseQueueMessage(action: String): EventAction</ID>
    <ID>UndocumentedPublicFunction:FTPSTransport.kt$FTPSTransport.Companion$// TODO - this needs an FTPSCredential once its known what that entails fun lookupCredentials(receiverFullName: String): SftpCredential</ID>
    <ID>UndocumentedPublicFunction:FakeReport.kt$FakeDataService$fun getFakeValueForElement( element: Element, context: FakeReport.RowContext, ): String</ID>
    <ID>UndocumentedPublicFunction:FakeReport.kt$FakeReport$fun build( schema: Schema, count: Int = 10, source: Source, targetStates: String? = null, targetCounties: String? = null ): Report</ID>
    <ID>UndocumentedPublicFunction:FileNameTemplate.kt$FileNameElement$fun getElementValue(args: List&lt;String> = emptyList(), translatorConfig: TranslatorConfiguration? = null): String</ID>
    <ID>UndocumentedPublicFunction:FileNameTemplate.kt$FileNameTemplate$fun getFileName( translatorConfig: TranslatorConfiguration? = null, reportId: ReportId ): String</ID>
    <ID>UndocumentedPublicFunction:FileNameTemplate.kt$FileNameTemplate.Companion$fun fixupFileNameElements(elements: List&lt;String>): List&lt;Pair&lt;Any, List&lt;String>>></ID>
    <ID>UndocumentedPublicFunction:FileNameTemplate.kt$FileNameTemplate.Companion$fun parseFileNameElement(fileNameElement: String): Pair&lt;String, List&lt;String>></ID>
    <ID>UndocumentedPublicFunction:FileSettings.kt$FileSettings$fun loadOrganizationList(organizations: List&lt;DeepOrganization>): FileSettings</ID>
    <ID>UndocumentedPublicFunction:FileSettings.kt$FileSettings$fun loadOrganizations(filePath: String): FileSettings</ID>
    <ID>UndocumentedPublicFunction:FileSettings.kt$FileSettings$fun loadOrganizations(organizationStream: InputStream): FileSettings</ID>
    <ID>UndocumentedPublicFunction:FileSettings.kt$FileSettings$fun loadOrganizations(vararg organizations: DeepOrganization): FileSettings</ID>
    <ID>UndocumentedPublicFunction:FileUtilities.kt$FileUtilities.Companion$fun createFakeFile( metadata: Metadata, settings: SettingsProvider, sender: Sender, count: Int, targetStates: String? = null, targetCounties: String? = null, directory: String = ".", format: Report.Format = Report.Format.CSV, locale: Locale? = null ): File</ID>
    <ID>UndocumentedPublicFunction:FileUtilities.kt$FileUtilities.Companion$fun createFakeReport( metadata: Metadata, sender: Sender, count: Int, targetStates: String? = null, targetCounties: String? = null, locale: Locale? = null ): Report</ID>
    <ID>UndocumentedPublicFunction:FileUtilities.kt$FileUtilities.Companion$fun replaceText( path: String?, findText: String, replaceText: String, ): File</ID>
    <ID>UndocumentedPublicFunction:FileUtilities.kt$FileUtilities.Companion$fun writeReportToFile( report: Report, format: Report.Format, metadata: Metadata, outputDir: String?, outputFileName: String?, settings: SettingsProvider ): File</ID>
    <ID>UndocumentedPublicFunction:FileUtilities.kt$FileUtilities.Companion$fun writeReportsToFile( reports: List&lt;Pair&lt;Report, Report.Format>>, metadata: Metadata, settings: SettingsProvider, outputDir: String?, outputFileName: String?, )</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Action.Builder$fun action(action: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Action.Builder$fun build()</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Action.Builder$fun date(date: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Action.Builder$fun user(user: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$BaseHistoryFunction$fun getFacilitiesForReportId( request: HttpRequestMessage&lt;String?>, reportId: String?, context: ExecutionContext ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$BaseHistoryFunction$fun getOrgNameFromHeader(orgNameHeader: String): String</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$BaseHistoryFunction$fun getReportById( request: HttpRequestMessage&lt;String?>, reportIdIn: String, context: ExecutionContext ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$BaseHistoryFunction$fun getReports( request: HttpRequestMessage&lt;String?>, context: ExecutionContext, organizationName: String? = null ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun CLIA(CLIA: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun build()</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun facility(facility: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun location(location: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun organization(organization: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun positive(positive: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$Facility.Builder$fun total(total: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$GetFacilitiesByReportId$@FunctionName("getFacilitiesByReportId") @StorageAccount("AzureWebJobsStorage") fun run( @HttpTrigger( name = "getFacilitiesByReportId", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "history/report/{reportId}/facilities" ) request: HttpRequestMessage&lt;String?>, @BindingName("reportId") reportId: String, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$GetReportById$@FunctionName("getReportById") @StorageAccount("AzureWebJobsStorage") fun run( @HttpTrigger( name = "getReportById", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "history/report/{reportId}" ) request: HttpRequestMessage&lt;String?>, @BindingName("reportId") reportId: String, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$GetReports$@FunctionName("getReports") @StorageAccount("AzureWebJobsStorage") fun run( @HttpTrigger( name = "getReports", methods = [HttpMethod.GET, HttpMethod.HEAD, HttpMethod.OPTIONS], authLevel = AuthorizationLevel.ANONYMOUS, route = "history/report" ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun actions(actions: ArrayList&lt;Action>)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun build()</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun content(content: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun displayName(displayName: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun expires(expires: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun facilities(facilities: ArrayList&lt;Facility>)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun fileName(fileName: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun fileType(fileType: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun mimeType(mimeType: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun positive(positive: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun receivingOrg(receivingOrg: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun receivingOrgSvc(receivingOrgSvc: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun reportId(reportId: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun sendingOrg(sendingOrg: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun sent(sent: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun total(total: Long)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun type(type: String)</ID>
    <ID>UndocumentedPublicFunction:HistoryFunctions.kt$ReportView.Builder$fun via(via: String)</ID>
    <ID>UndocumentedPublicFunction:Hl7Serializer.kt$Hl7Serializer$/* * Read in a file */ fun convertBatchMessagesToMap(message: String, schema: Schema): Hl7Mapping</ID>
    <ID>UndocumentedPublicFunction:Hl7Serializer.kt$Hl7Serializer$fun readExternal( schemaName: String, input: InputStream, source: Source ): ReadResult</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun badRequestResponse( request: HttpRequestMessage&lt;String?>, responseBody: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun createdResponse( request: HttpRequestMessage&lt;String?>, responseBody: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun errorJson(message: String): String</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun internalErrorResponse( request: HttpRequestMessage&lt;String?> ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun notFoundResponse( request: HttpRequestMessage&lt;String?>, errorMessage: String? = null ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun okResponse( request: HttpRequestMessage&lt;String?>, lastModified: OffsetDateTime?, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun okResponse( request: HttpRequestMessage&lt;String?>, responseBody: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun okResponse( request: HttpRequestMessage&lt;String?>, responseBody: String, lastModified: OffsetDateTime?, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun postReportBytesToWatersAPI( environment: Environment, bytes: ByteArray, sendingOrgClient: Sender, token: String? = null, option: Options? = null ): Pair&lt;Int, String></ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun unauthorizedResponse( request: HttpRequestMessage&lt;String?> ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:HttpUtilities.kt$HttpUtilities.Companion$fun unauthorizedResponse( request: HttpRequestMessage&lt;String?>, responseBody: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:JtiCache.kt$JtiCache$abstract fun cleanupCache()</ID>
    <ID>UndocumentedPublicFunction:JtiCache.kt$JtiCache$abstract fun insertIntoCache(jti: String, expiresAt: OffsetDateTime)</ID>
    <ID>UndocumentedPublicFunction:JtiCache.kt$JtiCache$abstract fun isPresentInCache(jti: String): Boolean</ID>
    <ID>UndocumentedPublicFunction:JurisdictionalFilters.kt$JurisdictionalFilters$fun logAllEliminated(beforeSize: Int, filterDescription: String, receiver: Receiver, doAuditing: Boolean)</ID>
    <ID>UndocumentedPublicFunction:JurisdictionalFilters.kt$JurisdictionalFilters$fun logFiltering( before: Selection, after: Selection, filterDescription: String, receiver: Receiver, doAuditing: Boolean )</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk$fun toECPrivateKey(): ECPrivateKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk$fun toECPublicKey(): ECPublicKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk$fun toRSAPrivateKey(): RSAPrivateKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk$fun toRSAPublicKey(): RSAPublicKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk.Companion$fun generateECPrivateKey(jwkString: String): ECPrivateKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk.Companion$fun generateECPublicKey(jwkString: String): ECPublicKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk.Companion$fun generateRSAPrivateKey(jwkString: String): RSAPrivateKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$Jwk.Companion$fun generateRSAPublicKey(jwkString: String): RSAPublicKey</ID>
    <ID>UndocumentedPublicFunction:Jwk.kt$JwkSet$fun filterByKid(kid: String): List&lt;Jwk></ID>
    <ID>UndocumentedPublicFunction:LookupTable.kt$LookupTable.Companion$fun read(fileName: String): LookupTable</ID>
    <ID>UndocumentedPublicFunction:LookupTable.kt$LookupTable.Companion$fun read(inputStream: InputStream, isTsv: Boolean = false): LookupTable</ID>
    <ID>UndocumentedPublicFunction:Mappers.kt$HashMapper.Companion$fun digest(input: ByteArray): String</ID>
    <ID>UndocumentedPublicFunction:Mappers.kt$Mappers$fun parseMapperField(field: String): Pair&lt;String, List&lt;String>></ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$// Load the schema catalog either from the default location or from the passed location fun loadSchemaCatalog(catalog: String): Metadata</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findFileNameTemplate(name: String): FileNameTemplate?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findJurisdictionalFilter(name: String): JurisdictionalFilter?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findLookupTable(name: String): LookupTable?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findMapper(name: String): Mapper?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findSchema(name: String): Schema?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun findValueSet(name: String): ValueSet?</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun loadLookupTable(name: String, table: LookupTable): Metadata</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun loadLookupTable(name: String, tableStream: InputStream): Metadata</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun loadSchemas(vararg schemas: Schema): Metadata</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun loadValueSetCatalog(catalog: String): Metadata</ID>
    <ID>UndocumentedPublicFunction:Metadata.kt$Metadata$fun loadValueSets(vararg sets: ValueSet): Metadata</ID>
    <ID>UndocumentedPublicFunction:OktaAuthentication.kt$OktaAuthentication$fun checkAccess( request: HttpRequestMessage&lt;String?>, organizationName: String = "", oktaSender: Boolean = false, block: (AuthenticatedClaims) -> HttpResponseMessage ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:OktaAuthentication.kt$OktaAuthentication$fun getAccessToken(request: HttpRequestMessage&lt;String?>): String?</ID>
    <ID>UndocumentedPublicFunction:OktaAuthentication.kt$OktaAuthentication.Companion$fun authenticationVerifier(): AuthenticationVerifier</ID>
    <ID>UndocumentedPublicFunction:OktaAuthentication.kt$OktaAuthentication.Companion$fun setRequest(request: HttpRequestMessage&lt;String?>)</ID>
    <ID>UndocumentedPublicFunction:OktaCommands.kt$OktaCommand$fun abort(message: String): Nothing</ID>
    <ID>UndocumentedPublicFunction:OktaCommands.kt$OktaCommand.Companion$fun deleteAccessTokenFile()</ID>
    <ID>UndocumentedPublicFunction:OktaCommands.kt$OktaCommand.Companion$fun isValidToken(oktaApp: OktaApp, accessTokenFile: AccessTokenFile): Boolean</ID>
    <ID>UndocumentedPublicFunction:OktaCommands.kt$OktaCommand.Companion$fun readAccessTokenFile(): AccessTokenFile?</ID>
    <ID>UndocumentedPublicFunction:OktaCommands.kt$OktaCommand.Companion$fun writeAccessTokenFile(oktaApp: OktaApp, accessTokenJson: JSONObject): AccessTokenFile</ID>
    <ID>UndocumentedPublicFunction:ProcessFunction.kt$ProcessFunction$@FunctionName(azureFunctionName) @StorageAccount("AzureWebJobsStorage") fun run( @QueueTrigger(name = "message", queueName = azureQueueName) message: String, context: ExecutionContext, )</ID>
    <ID>UndocumentedPublicFunction:QueueAccess.kt$QueueAccess$fun receiveMessage(queueName: String): Event</ID>
    <ID>UndocumentedPublicFunction:ReadResult.kt$ReadResult$fun errorsToString(): String</ID>
    <ID>UndocumentedPublicFunction:ReadResult.kt$ReadResult$fun warningsToString(): String</ID>
    <ID>UndocumentedPublicFunction:Receiver.kt$Receiver.Companion$fun parseFullName(fullName: String): Pair&lt;String, String></ID>
    <ID>UndocumentedPublicFunction:Receiver.kt$Receiver.Timing$@JsonIgnore fun isValid(): Boolean</ID>
    <ID>UndocumentedPublicFunction:RedoxSerializer.kt$RedoxSerializer$fun write(report: Report, outputStream: OutputStream)</ID>
    <ID>UndocumentedPublicFunction:RedoxTransport.kt$RedoxTransport$fun fetchToken( redox: RedoxTransportType, key: String, secret: String, context: ExecutionContext ): String?</ID>
    <ID>UndocumentedPublicFunction:RedoxTransport.kt$RedoxTransport$fun sendItem( sendUrl: String, token: String, message: String, id: String, ): SendResult</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$// takes the data in the existing report and synthesizes different data from it // the goal is to allow us to take real data in, move it around and scramble it so it's // not able to point back to the actual records fun synthesizeData( synthesizeStrategies: Map&lt;String, SynthesizeStrategy> = emptyMap(), targetState: String? = null, targetCounty: String? = null, metadata: Metadata, ): Report</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun applyMapping(mapping: Translator.Mapping): Report</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun deidentify(): Report</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun filter( filterFunctions: List&lt;Pair&lt;JurisdictionalFilter, List&lt;String>>>, receiver: Receiver, isQualityFilter: Boolean, reverseTheFilter: Boolean = false ): Report</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun getRow(row: Int): List&lt;String></ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun getString(row: Int, colName: String, maxLength: Int? = null): String?</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun getString(row: Int, column: Int, maxLength: Int? = null): String?</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun getStringByHl7Field(row: Int, hl7Field: String, maxLength: Int? = null): String?</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report$fun isEmpty(): Boolean</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun createItemLineages(parentReports: List&lt;Report>, childReport: Report): List&lt;ItemLineage></ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun createOneToOneItemLineages(parentReport: Report, childReport: Report): List&lt;ItemLineage></ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun decorateItemLineagesWithTransportResults(itemLineages: List&lt;ItemLineage>, transportResults: List&lt;String>)</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun formExternalFilename( bodyUrl: String?, reportId: ReportId, schemaName: String, format: Format, createdAt: OffsetDateTime ): String</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun formFilename( id: ReportId, schemaName: String, fileFormat: Format?, createdDateTime: OffsetDateTime, nameFormat: String = "standard", translationConfig: TranslatorConfiguration? = null, metadata: Metadata ): String</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun formFilename( id: ReportId, schemaName: String, fileFormat: Format?, createdDateTime: OffsetDateTime, translationConfig: TranslatorConfiguration? = null, metadata: Metadata ): String</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Companion$fun merge(inputs: List&lt;Report>): Report</ID>
    <ID>UndocumentedPublicFunction:Report.kt$Report.Format.Companion$// Default to CSV if weird or unknown fun safeValueOf(formatStr: String?): Format</ID>
    <ID>UndocumentedPublicFunction:ReportStreamSecretFinder.kt$ReportStreamSecretFinder$fun getReportStreamTokenSigningSecret(): SecretKey</ID>
    <ID>UndocumentedPublicFunction:ReportStreamSecretFinder.kt$ReportStreamSecretFinder.Companion$// convenience method that knows how to generate the right kind of secret. fun generateSecret(): String</ID>
    <ID>UndocumentedPublicFunction:RequeueFunction.kt$RequeueFunction$@FunctionName("requeue") // devnote: putting slashes in this (/) breaks it. fun run( @HttpTrigger( name = "requeue", methods = [HttpMethod.POST], authLevel = AuthorizationLevel.FUNCTION, route = "requeue/send" ) request: HttpRequestMessage&lt;String?>, context: ExecutionContext, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:RequeueFunction.kt$RequeueFunction$fun doResend( request: HttpRequestMessage&lt;String?>, workflowEngine: WorkflowEngine, msgs: MutableList&lt;String>, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:ResponseMessage.kt$ResponseMessage$fun detailMsg(): String</ID>
    <ID>UndocumentedPublicFunction:ResponseMessage.kt$ResponseMessage$fun groupingId(): String</ID>
    <ID>UndocumentedPublicFunction:ResultDetail.kt$ResultDetail.Companion$fun item(id: String, message: ResponseMessage, row: Int): ResultDetail</ID>
    <ID>UndocumentedPublicFunction:ResultDetail.kt$ResultDetail.Companion$fun param(id: String, message: ResponseMessage): ResultDetail</ID>
    <ID>UndocumentedPublicFunction:ResultDetail.kt$ResultDetail.Companion$fun report(message: ResponseMessage): ResultDetail</ID>
    <ID>UndocumentedPublicFunction:ResultDetail.kt$ResultDetail.Companion$fun translation(id: String, message: ResponseMessage): ResultDetail</ID>
    <ID>UndocumentedPublicFunction:RetryToken.kt$RetryToken$fun toJSON(): String</ID>
    <ID>UndocumentedPublicFunction:RetryToken.kt$RetryToken.Companion$fun fromJSON(json: String?): RetryToken?</ID>
    <ID>UndocumentedPublicFunction:RetryToken.kt$RetryToken.Companion$fun isAllItems(items: RetryItems?): Boolean</ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema$fun containsElement(name: String): Boolean</ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema$fun filterCsvFields(block: (Element) -> Boolean): List&lt;Element.CsvField></ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema$fun findElement(name: String): Element?</ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema$fun findElementByCsvName(name: String): Element?</ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema$fun findElementColumn(name: String): Int?</ID>
    <ID>UndocumentedPublicFunction:Schema.kt$Schema.Companion$fun formBaseName(name: String): String</ID>
    <ID>UndocumentedPublicFunction:Scope.kt$Scope.Companion$fun generateValidScope(sender: Sender, detailedScope: String): String</ID>
    <ID>UndocumentedPublicFunction:Scope.kt$Scope.Companion$fun isValidScope(scope: String, expectedSender: Sender): Boolean</ID>
    <ID>UndocumentedPublicFunction:Scope.kt$Scope.Companion$fun isWellFormedScope(scope: String): Boolean</ID>
    <ID>UndocumentedPublicFunction:Scope.kt$Scope.Companion$fun scopeListContainsScope(scopeList: String, desiredScope: String): Boolean</ID>
    <ID>UndocumentedPublicFunction:SecretManagement.kt$SecretHelper.Companion$fun getSecretService(): SecretService</ID>
    <ID>UndocumentedPublicFunction:SecretService.kt$SecretService$fun fetchSecret(secretName: String): String?</ID>
    <ID>UndocumentedPublicFunction:SendFunction.kt$SendFunction$@FunctionName(send) @StorageAccount("AzureWebJobsStorage") fun run( @QueueTrigger(name = "msg", queueName = send) message: String, context: ExecutionContext, @BindingName("Id") messageId: String? = null, @BindingName("DequeueCount") dequeueCount: Int? = null, @BindingName("NextVisibleTime") nextVisibleTime: Date? = null, @BindingName("InsertionTime") insertionTime: Date? = null, )</ID>
    <ID>UndocumentedPublicFunction:Sender.kt$Sender$fun findKeySetByScope(scope: String): JwkSet?</ID>
    <ID>UndocumentedPublicFunction:Sender.kt$Sender.Companion$fun canonicalizeFullName(fullName: String): String</ID>
    <ID>UndocumentedPublicFunction:Sender.kt$Sender.Companion$fun parseFullName(fullName: String): Pair&lt;String, String></ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun generateSenderUrl(environment: Environment, senderToken: String, scope: String): URL</ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun generateSenderUrlParameters(senderToken: String, scope: String): Map&lt;String, String></ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun readPrivateKeyPem(pem: String): PrivateKey</ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun readPrivateKeyPemFile(pemFile: File): PrivateKey</ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun readPublicKeyPem(pem: String): Jwk</ID>
    <ID>UndocumentedPublicFunction:SenderUtils.kt$SenderUtils.Companion$fun readPublicKeyPemFile(pemFile: File): Jwk</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$GetMultipleSettings$fun getAll(environment: Environment, accessToken: String): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$PutMultipleSettings$fun putAll(environment: Environment, accessToken: String): List&lt;String></ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$PutMultipleSettings$fun readYaml(): List&lt;DeepOrganization></ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun delete(environment: Environment, accessToken: String, settingType: SettingType, settingName: String): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun fromJson(input: String, settingType: SettingType): Pair&lt;String, String></ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun fromYaml(input: String, settingType: SettingType): Pair&lt;String, String></ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun get(environment: Environment, accessToken: String, settingType: SettingType, settingName: String): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun getAccessToken(environment: Environment): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun getMany(environment: Environment, accessToken: String, settingType: SettingType, settingName: String): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun listNames( environment: Environment, accessToken: String, settingType: SettingType, settingName: String ): List&lt;String></ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun put( environment: Environment, accessToken: String, settingType: SettingType, settingName: String, payload: String ): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun readInput(): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun toYaml(output: String, settingType: SettingType): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand$fun writeOutput(output: String)</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand.Companion$fun abort(message: String): Nothing</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand.Companion$fun formPath( environment: Environment, operation: Operation, settingType: SettingType, settingName: String ): String</ID>
    <ID>UndocumentedPublicFunction:SettingCommands.kt$SettingCommand.Companion$fun settingPath(operation: Operation, settingType: SettingType, settingName: String): String</ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingAPI$fun consistencyErrorMessage(metadata: Metadata): String?</ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun &lt;T : SettingAPI> deleteSetting( name: String, claims: AuthenticatedClaims, clazz: Class&lt;T>, organizationName: String? = null ): Pair&lt;AccessResult, String></ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun &lt;T : SettingAPI> findSettingAsJson( name: String, clazz: Class&lt;T>, organizationName: String? = null, ): String?</ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun &lt;T : SettingAPI> findSettingsAsJson(clazz: Class&lt;T>): String</ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun &lt;T : SettingAPI> findSettingsAsJson(organizationName: String, clazz: Class&lt;T>): Pair&lt;AccessResult, String></ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun &lt;T : SettingAPI> putSetting( name: String, json: String, claims: AuthenticatedClaims, clazz: Class&lt;T>, organizationName: String? = null ): Pair&lt;AccessResult, String></ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun findOrganizationAndReceiver(fullName: String, txn: DataAccessTransaction?): Pair&lt;Organization, Receiver>?</ID>
    <ID>UndocumentedPublicFunction:SettingsFacade.kt$SettingsFacade$fun getLastModified(): OffsetDateTime?</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$BaseFunction$fun &lt;T : SettingAPI> getList( request: HttpRequestMessage&lt;String?>, clazz: Class&lt;T> ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$BaseFunction$fun &lt;T : SettingAPI> getList( request: HttpRequestMessage&lt;String?>, organizationName: String, clazz: Class&lt;T> ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$BaseFunction$fun &lt;T : SettingAPI> getOne( request: HttpRequestMessage&lt;String?>, settingName: String, clazz: Class&lt;T>, organizationName: String? = null, oktaSender: Boolean = false ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$BaseFunction$fun &lt;T : SettingAPI> updateOne( request: HttpRequestMessage&lt;String?>, settingName: String, clazz: Class&lt;T>, organizationName: String? = null ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$BaseFunction$fun getHead( request: HttpRequestMessage&lt;String?> ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetOneOrganization$@FunctionName("getOneOrganization") fun run( @HttpTrigger( name = "getOneOrganization", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetOneReceiver$@FunctionName("getOneReceiver") fun run( @HttpTrigger( name = "getOneReceiver", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/receivers/{receiverName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, @BindingName("receiverName") receiverName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetOneSender$@FunctionName("getOneSender") fun run( @HttpTrigger( name = "getOneSender", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/senders/{senderName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, @BindingName("senderName") senderName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetOrganizations$@FunctionName("getOrganizations") fun run( @HttpTrigger( name = "getOrganizations", methods = [HttpMethod.GET, HttpMethod.HEAD], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations" ) request: HttpRequestMessage&lt;String?>, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetReceiver$@FunctionName("getReceivers") fun run( @HttpTrigger( name = "getReceivers", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/receivers" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$GetSenders$@FunctionName("getSenders") fun run( @HttpTrigger( name = "getSenders", methods = [HttpMethod.GET], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/senders" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$UpdateOrganization$@FunctionName("updateOneOrganization") fun run( @HttpTrigger( name = "updateOneOrganization", methods = [HttpMethod.DELETE, HttpMethod.PUT], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$UpdateReceiver$@FunctionName("updateOneReceiver") fun run( @HttpTrigger( name = "updateOneReceiver", methods = [HttpMethod.DELETE, HttpMethod.PUT], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/receivers/{receiverName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, @BindingName("receiverName") receiverName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsFunctions.kt$UpdateSender$@FunctionName("updateOneSender") fun run( @HttpTrigger( name = "updateOneSender", methods = [HttpMethod.DELETE, HttpMethod.PUT], authLevel = AuthorizationLevel.ANONYMOUS, route = "settings/organizations/{organizationName}/senders/{senderName}" ) request: HttpRequestMessage&lt;String?>, @BindingName("organizationName") organizationName: String, @BindingName("senderName") senderName: String, ): HttpResponseMessage</ID>
    <ID>UndocumentedPublicFunction:SettingsProvider.kt$SettingsProvider$fun findOrganization(name: String): Organization?</ID>
    <ID>UndocumentedPublicFunction:SettingsProvider.kt$SettingsProvider$fun findOrganizationAndReceiver(fullName: String): Pair&lt;Organization, Receiver>?</ID>
    <ID>UndocumentedPublicFunction:SettingsProvider.kt$SettingsProvider$fun findReceiver(fullName: String): Receiver?</ID>
    <ID>UndocumentedPublicFunction:SettingsProvider.kt$SettingsProvider$fun findSender(fullName: String): Sender?</ID>
    <ID>UndocumentedPublicFunction:SftpTransport.kt$SftpTransport.Companion$fun ls(sshClient: SSHClient, path: String): List&lt;String></ID>
    <ID>UndocumentedPublicFunction:SftpTransport.kt$SftpTransport.Companion$fun ls(sshClient: SSHClient, path: String, resourceFilter: RemoteResourceFilter?): List&lt;String></ID>
    <ID>UndocumentedPublicFunction:SftpTransport.kt$SftpTransport.Companion$fun pwd(sshClient: SSHClient): String</ID>
    <ID>UndocumentedPublicFunction:SftpTransport.kt$SftpTransport.Companion$fun rm(sshClient: SSHClient, path: String, fileName: String)</ID>
    <ID>UndocumentedPublicFunction:TokenAuthentication.kt$FindSenderKeyInSettings$fun err(shortMsg: String): Key?</ID>
    <ID>UndocumentedPublicFunction:TokenAuthentication.kt$TokenAuthentication$fun checkAccessToken(request: HttpRequestMessage&lt;String?>, desiredScope: String): Claims?</ID>
    <ID>UndocumentedPublicFunction:TokenAuthentication.kt$TokenAuthentication$fun createAccessToken( scopeAuthorized: String, lookup: ReportStreamSecretFinder, actionHistory: ActionHistory? = null, ): AccessToken</ID>
    <ID>UndocumentedPublicFunction:TokenAuthentication.kt$TokenAuthentication.Companion$fun isExpiredToken(exp: Date): Boolean</ID>
    <ID>UndocumentedPublicFunction:Translator.kt$Translator$fun translate( input: Report, toReceiver: String, defaultValues: DefaultValues = emptyMap() ): Pair&lt;Report, Receiver>?</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$// set a version on the whole value set if you want, but you can still use // the value-specific version if you're adding something from a different version fun toVersionFromCode(code: String): String?</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$fun mergeAltValues(altValues: List&lt;Value>?): ValueSet</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$fun toCodeFromDisplay(display: String): String?</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$fun toDisplayFromCode(code: String): String?</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$fun toNormalizedCode(code: String): String?</ID>
    <ID>UndocumentedPublicFunction:ValueSet.kt$ValueSet$fun toSystemFromCode(code: String): String?</ID>
    <ID>UndocumentedPublicFunction:WorkflowEngine.kt$WorkflowEngine$// routeReport does all filtering and translating per receiver, generating one file per receiver to then be batched fun routeReport( context: ExecutionContext, report: Report, options: Options, defaults: Map&lt;String, String>, routeTo: List&lt;String>, warnings: MutableList&lt;ResultDetail>, actionHistory: ActionHistory, )</ID>
    <ID>UndocumentedPublicFunction:WorkflowEngine.kt$WorkflowEngine$fun fetchDownloadableReportFiles( since: OffsetDateTime?, organizationName: String, ): List&lt;ReportFile></ID>
    <ID>UndocumentedPublicFunction:WorkflowEngine.kt$WorkflowEngine$fun fetchHeader( reportId: ReportId, organization: Organization, fetchBlobBody: Boolean = true ): Header</ID>
    <ID>UndocumentedPublicFunction:WorkflowEngine.kt$WorkflowEngine$fun insertProcessTask( report: Report, reportFormat: String, reportUrl: String, nextAction: Event )</ID>
    <ID>UndocumentedPublicFunction:WorkflowEngine.kt$WorkflowEngine$fun recordAction(actionHistory: ActionHistory, txn: Configuration? = null)</ID>
    <ID>UndocumentedPublicFunction:main.kt$GenerateDocs$fun generateSchemaDocumentation(metadata: Metadata)</ID>
    <ID>UndocumentedPublicFunction:main.kt$ListSchemas$fun listOrganizations(settings: SettingsProvider)</ID>
    <ID>UndocumentedPublicFunction:main.kt$fun listSchemas(metadata: Metadata)</ID>
    <ID>UndocumentedPublicFunction:main.kt$fun main(args: Array&lt;String>)</ID>
    <ID>UndocumentedPublicProperty:AS2Transport.kt$const val TIMEOUT = 10_000</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory$/* * New reports generated by this action. * For this action, we insert these into report_file, and as children into report_lineage. */ val reportsOut = mutableMapOf&lt;ReportId, ReportFile>()</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory$/* * Reports that are inputs to this action, from external source. * Note that this should be able to handle multiple submitted reports in one action. * For this action, we insert these into report_file, and as parents into report_lineage. */ val reportsReceived = mutableMapOf&lt;ReportId, ReportFile>()</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory$/* * Reports that are inputs to this action, from previous steps. * These reports are already in report_file. For this action, we insert them as parents into * report_lineage. */ val reportsIn = mutableMapOf&lt;ReportId, ReportFile>()</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory$/* * Stores covid metadata records that are created when a new report is received with the topic covid-19 */ val covidMetaDataRecords = mutableListOf&lt;CovidResultMetadata>()</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory.ItemRouting$val destinations: MutableList&lt;String> = mutableListOf()</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory.ItemRouting$val reportIndex: Int</ID>
    <ID>UndocumentedPublicProperty:ActionHistory.kt$ActionHistory.ItemRouting$val trackingId: String?</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$// These constants match how PRIME Okta subscription is configured const val oktaGroupPrefix = "DH"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$AuthenticatedClaims$val organizationName: String?</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$AuthenticatedClaims$val principalLevel: PrincipalLevel</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$AuthenticatedClaims$val userName: String</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val envVariableForOktaBaseUrl = "OKTA_baseUrl"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val oktaAdminGroupSuffix = "Admins"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val oktaMembershipClaim = "organization"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val oktaSenderGroupPrefix = "DHSender_"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val oktaSubjectClaim = "sub"</ID>
    <ID>UndocumentedPublicProperty:Authentication.kt$const val oktaSystemAdminGroup = "DHPrimeAdmins"</ID>
    <ID>UndocumentedPublicProperty:BatchFunction.kt$const val batch = "batch"</ID>
    <ID>UndocumentedPublicProperty:BatchFunction.kt$const val defaultBatchSize = 100</ID>
    <ID>UndocumentedPublicProperty:BlobAccess.kt$BlobAccess.BlobInfo$val blobUrl: String</ID>
    <ID>UndocumentedPublicProperty:BlobAccess.kt$BlobAccess.BlobInfo$val digest: ByteArray</ID>
    <ID>UndocumentedPublicProperty:BlobAccess.kt$BlobAccess.BlobInfo$val format: Report.Format</ID>
    <ID>UndocumentedPublicProperty:BlobAccess.kt$const val defaultBlobContainerName = "reports"</ID>
    <ID>UndocumentedPublicProperty:BlobStoreTransport.kt$BlobStoreTransport$val workflowEngine: WorkflowEngine</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val checkResult: String</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val checkSuccessful: Boolean</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val completedAt: Instant</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val initiatedOn: Instant</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val organizationId: Int</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.RemoteConnectionCheck$val receiverId: Int</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.SftpFile$val contents: String</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.SftpFile$val name: String</ID>
    <ID>UndocumentedPublicProperty:CheckFunction.kt$CheckFunction.TestFileFilter$val fileName: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPassCredential$val pass: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPassCredential$val user: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPemCredential$val key: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPemCredential$val keyPass: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPemCredential$val pass: String? = null</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPemCredential$val user: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPpkCredential$val key: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPpkCredential$val keyPass: String</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPpkCredential$val pass: String? = null</ID>
    <ID>UndocumentedPublicProperty:Credential.kt$UserPpkCredential$val user: String</ID>
    <ID>UndocumentedPublicProperty:CredentialManagement.kt$CredentialManagement$@Suppress("unused") val credentialService: CredentialService get() = credentialServiceForStorageMethod()</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$CredentialsCli$val persist by option(help = "credentialId to persist the secret under")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$CredentialsCli$val type by option(help = "Type of credential to create") .groupChoice( "UserPass" to UserPassCredentialOptions(), "UserPem" to UserPemCredentialOptions(), "UserPpk" to UserPpkCredentialOptions(), "UserJks" to UserJksCredentialOptions() ).required()</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserJksCredentialOptions$val file by option("--jks-file", help = "Path to the JKS file").file(mustExist = true) .required()</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserJksCredentialOptions$val filePass by option("--jks-file-pass", help = "the JKS passcode (optional)") .prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserJksCredentialOptions$val privateAlias by option("--jks-private-alias", help = "the JKS alias that points to the ID certificate") .default("cdcprime")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserJksCredentialOptions$val trustAlias by option("--jks-trust-alias", help = "the JKS alias that points to a trust certificate") .default("as2ohp")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserJksCredentialOptions$val user by option("--jks-user", help = "Username to authenticate alongside the JKS") .prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPassCredentialOptions$val pass by option(help = "SFTP password").prompt(default = "", requireConfirmation = true)</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPassCredentialOptions$val user by option(help = "SFTP username").prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPemCredentialOptions$val file by option("--pem-file", help = "Path to the PEM file").file(mustExist = true).required()</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPemCredentialOptions$val filePass by option("--pem-file-pass", help = "Password to decrypt the PEM").prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPemCredentialOptions$val pass by option( "--pem-user-pass", help = "The password to use to login with the user if the SFTP server is using partial auth" ).prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPemCredentialOptions$val user by option("--pem-user", help = "Username to authenticate alongside the PEM").prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPpkCredentialOptions$val file by option("--ppk-file", help = "Path to the PPK file").file(mustExist = true).required()</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPpkCredentialOptions$val filePass by option("--ppk-file-pass", help = "Password to decrypt the PPK (optional)").prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPpkCredentialOptions$val pass by option( "--ppk-user-pass", help = "The password to use to login with the user if the SFTP server is using partial auth" ).prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CredentialsCli.kt$UserPpkCredentialOptions$val user by option("--ppk-user", help = "Username to authenticate alongside the PPK").prompt(default = "")</ID>
    <ID>UndocumentedPublicProperty:CsvComparer.kt$CsvComparer$val fileOnePath: String</ID>
    <ID>UndocumentedPublicProperty:CsvComparer.kt$CsvComparer$val fileTwoPath: String</ID>
    <ID>UndocumentedPublicProperty:CsvComparer.kt$CsvComparer$val recordId: String = "Patient_Id"</ID>
    <ID>UndocumentedPublicProperty:CsvComparer.kt$HeaderComparison$val fileOneHeaders: Set&lt;String></ID>
    <ID>UndocumentedPublicProperty:CsvComparer.kt$HeaderComparison$val fileTwoHeaders: Set&lt;String></ID>
    <ID>UndocumentedPublicProperty:CsvSerializer.kt$CsvSerializer$val metadata: Metadata</ID>
    <ID>UndocumentedPublicProperty:CsvSerializer.kt$CsvSerializer.Companion$const val REPORSTREAM_SUPPORT_EMAIL = "reportstream@cdc.gov"</ID>
    <ID>UndocumentedPublicProperty:DatabaseAccess.kt$// general max length of free from metadata strings since jooq/postgres // does not truncate values when persisting to the database const val METADATA_MAX_LENGTH = 512</ID>
    <ID>UndocumentedPublicProperty:DatabaseAccess.kt$DatabaseAccess.Companion$val commonDataSource: DataSource get() = hikariDataSource</ID>
    <ID>UndocumentedPublicProperty:DatabaseAccess.kt$const val databaseVariable = "POSTGRES_URL"</ID>
    <ID>UndocumentedPublicProperty:DatabaseAccess.kt$const val passwordVariable = "POSTGRES_PASSWORD"</ID>
    <ID>UndocumentedPublicProperty:DatabaseAccess.kt$const val userVariable = "POSTGRES_USER"</ID>
    <ID>UndocumentedPublicProperty:DatabaseJtiCache.kt$DatabaseJtiCache$val db: DatabaseAccess</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$// Creates a field mapping string showing the external CSV header name(s) // and the corresponding internal field name val fieldMapping get() = "'${this.csvFields?.joinToString { it -> it.name }}' ('${this.name}')"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val altValues: List&lt;ValueSet.Value>? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val canBeBlank get() = type == Type.TEXT_OR_BLANK || type == Type.STREET_OR_BLANK || type == Type.TABLE_OR_BLANK || type == Type.BLANK</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val cardinality: Cardinality? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val default: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val delimiter: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val documentation: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val fhirField: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val hhsGuidanceField: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val hl7AOEQuestion: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val hl7Field: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val hl7OutputFields: List&lt;String>? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val isCodeType get() = this.type == Type.CODE</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val isOptional get() = this.cardinality == null || this.cardinality == ZERO_OR_ONE || canBeBlank</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val mapper: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val mapperArgs: List&lt;String>? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val mapperOverridesValue: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val mapperRef: Mapper? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val maxLength: Int? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val name: String</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val natFlatFileField: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val phi: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val pii: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val redoxOutputFields: List&lt;String>? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val reference: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val referenceUrl: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val table: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val tableColumn: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val tableRef: LookupTable? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val valueSet: String? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element$val valueSetRef: ValueSet? = null</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val altDisplayToken = "\$alt"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val areaCodeToken = "\$area"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val caretToken = "\$code^\$display^\$system"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val codeToken = "\$code"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val countryCodeToken = "\$country"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val datePattern = "yyyyMMdd"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val datetimePattern = "yyyyMMddHHmmZZZ"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val defaultPhoneFormat = "\$area\$exchange\$subscriber"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val displayToken = "\$display"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val e164Token = "\$e164"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiCompleteFormat = "\$complete"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiDelimiter = "^"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiNameToken = "\$name"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiNamespaceIdToken = "\$namespaceId"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiSystemToken = "\$system"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val eiUniversalIdToken = "\$universalId"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val exchangeToken = "\$exchange"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val extensionToken = "\$extension"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val hdCompleteFormat = "\$complete"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val hdDelimiter = "^"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val hdNameToken = "\$name"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val hdSystemToken = "\$system"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val hdUniversalIdToken = "\$universalId"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val phoneDelimiter = ":"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val subscriberToken = "\$subscriber"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val systemToken = "\$system"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val usZipFormat = """^(\d{5})[- ]?(\d{4})?$"""</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val variableDateTimePattern = "[yyyyMMddHHmmssZ][yyyyMMddHHmmZ][yyyyMMddHHmmss]"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val zipDefaultFormat = zipFiveToken</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val zipFivePlusFourToken = "\$zipFivePlusFour"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$const val zipFiveToken = "\$zipFive"</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$val dateFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern(datePattern, Locale.ENGLISH)</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$val datetimeFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern(datetimePattern, Locale.ENGLISH)</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.Companion$val phoneNumberUtil: PhoneNumberUtil = PhoneNumberUtil.getInstance()</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.CsvField$val format: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.CsvField$val name: String</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.EIFields$val name: String</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.EIFields$val namespace: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.EIFields$val universalId: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.EIFields$val universalIdSystem: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.HDFields$val name: String</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.HDFields$val universalId: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.HDFields$val universalIdSystem: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.SubValue$val format: String?</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.SubValue$val name: String</ID>
    <ID>UndocumentedPublicProperty:Element.kt$Element.SubValue$val value: String</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidCodeMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidCodeMessage$val format: String? = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidCodeMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidDateMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidDateMessage$val format: String? = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidDateMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidHL7Message$val message: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidParamMessage$val message: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidPhoneMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidPhoneMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidPostalMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidPostalMessage$val format: String? = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidPostalMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidReportMessage$val message: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$InvalidTranslationMessage$val message: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$MissingFieldMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$MissingFieldMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$UnsupportedEIMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$UnsupportedEIMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$UnsupportedHDMessage$val fieldMapping: String = ""</ID>
    <ID>UndocumentedPublicProperty:ElementErrors.kt$UnsupportedHDMessage$val formattedValue: String = ""</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val cronSchedule: String</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val emails: List&lt;String> = ArrayList&lt;String>()</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val organizations: List&lt;String> = ArrayList&lt;String>()</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val parameters: Map&lt;String, String> = HashMap&lt;String, String>()</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val template: String</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailSchedule$val type: String</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$EmailScheduleEngine$val workflowEngine = WorkflowEngine()</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val ADMIN_GRP = "DHPrimeAdmins"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val AUTH_KEY = "Bearer "</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val FIVE_MINUTES_IN_SECONDS = 5 * 60</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val FROM_EMAIL = "reportstream@cdc.gov"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val OKTA_GROUPS_API = "https://hhs-prime-admin.okta.com/api/v1/groups"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val OKTA_ISSUER = "https://hhs-prime.okta.com/oauth2/default"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val ORG_CLAIM = "organization"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val SCHEDULE = "*/5 * * * *" // every 5 minutes</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val SUBJECT_EMAIL = "ReportStream Daily Email"</ID>
    <ID>UndocumentedPublicProperty:EmailEngineFunction.kt$const val USER_CLAIM = "sub"</ID>
    <ID>UndocumentedPublicProperty:Environment.kt$Environment$val envName: String</ID>
    <ID>UndocumentedPublicProperty:Environment.kt$Environment$val oktaApp: OktaCommand.OktaApp? = null</ID>
    <ID>UndocumentedPublicProperty:Environment.kt$Environment$val url: URL</ID>
    <ID>UndocumentedPublicProperty:Event.kt$Event$val at: OffsetDateTime?</ID>
    <ID>UndocumentedPublicProperty:Event.kt$Event$val eventAction: EventAction</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ProcessEvent.Companion$const val eventType = "process"</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ReceiverEvent$val receiverName: String</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ReceiverEvent.Companion$const val eventType = "receiver"</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ReportEvent$val reportId: UUID</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ReportEvent$val retryToken: RetryToken? = null</ID>
    <ID>UndocumentedPublicProperty:Event.kt$ReportEvent.Companion$const val eventType = "report"</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport$val locale: Locale? = null</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport$val metadata: Metadata</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$// find our county val county: String = reportCounty ?: findLookupTable("fips-county")?.let { when (state) { "AZ" -> randomChoice("Pima", "Yuma") "PA" -> randomChoice("Bucks", "Chester", "Montgomery") else -> randomChoice(it.filter("State", state, "County")) } } ?: "Prime"</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$// find our state val state: String = reportState ?: randomChoice("FL", "PA", "TX", "AZ", "ND", "CO", "LA", "NM", "VT", "GU")</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$// find our zipcode val zipCode: String = findLookupTable("zip-code-data")?.let { randomChoice( it.filter( "zipcode", mapOf( "state_abbr" to state, "county" to county ) ) ) } ?: faker.address().zipCode().toString()</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val city: String = findLookupTable("zip-code-data")?.let { randomChoice( it.filter( "city", mapOf( "state_abbr" to state, "county" to county, "zipcode" to zipCode ) ) ) } ?: faker.address().city().toString()</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val equipmentModel = randomChoice( // Use only equipment that have equipment UID and equipment UID type to pass quality gate for HL7 messages "LumiraDx SARS-CoV-2 Ag Test*", "BD Veritor System for Rapid Detection of SARS-CoV-2*" )</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val faker = if (locale == null) Faker() else Faker(locale)</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val locale: Locale? = null</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val patientName: Name = faker.name()</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val schemaName: String? = null</ID>
    <ID>UndocumentedPublicProperty:FakeReport.kt$FakeReport.RowContext$val schoolName: String = faker.university().name()</ID>
    <ID>UndocumentedPublicProperty:FileNameTemplate.kt$FileNameElement$val name: String</ID>
    <ID>UndocumentedPublicProperty:FileNameTemplate.kt$FileNameTemplate$val elements: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:FileNameTemplate.kt$FileNameTemplate$val lowerCase: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:FileNameTemplate.kt$FileNameTemplate$val name: String? = null</ID>
    <ID>UndocumentedPublicProperty:FileNameTemplate.kt$FileNameTemplate$val upperCase: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:FileSettings.kt$FileSettings.Companion$const val defaultSettingsDirectory = "./settings"</ID>
    <ID>UndocumentedPublicProperty:FileSettings.kt$FileSettings.Companion$const val organizationsBaseName = "organizations"</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action$val action: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action$val date: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action$val user: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action.Builder$var action: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action.Builder$var date: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Action.Builder$var user: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$BaseHistoryFunction$val DAYS_TO_SHOW = 30L</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$BaseHistoryFunction$val workflowEngine = WorkflowEngine()</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$BaseHistoryFunction.AuthClaims$val organization: Organization</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$BaseHistoryFunction.AuthClaims$val userName: String</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val CLIA: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val facility: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val location: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val organization: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val positive: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility$val total: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var CLIA: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var facility: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var location: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var organization: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var positive: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$Facility.Builder$var total: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$FileReturn$val content: String</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$FileReturn$val filename: String</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$FileReturn$val mimetype: String</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val actions: ArrayList&lt;Action>?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val content: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val displayName: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val expires: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val facilities: ArrayList&lt;Facility>?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val fileName: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val fileType: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val mimeType: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val positive: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val receivingOrg: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val receivingOrgSvc: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val reportId: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val sendingOrg: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val sent: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val total: Long?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val type: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView$val via: String?</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var actions: ArrayList&lt;Action>? = ArrayList&lt;Action>()</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var content: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var displayName: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var expires: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var facilities: ArrayList&lt;Facility>? = ArrayList&lt;Facility>()</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var fileName: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var fileType: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var mimeType: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var positive: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var receivingOrg: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var receivingOrgSvc: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var reportId: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var sendingOrg: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var sent: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var total: Long? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var type: String? = null</ID>
    <ID>UndocumentedPublicProperty:HistoryFunctions.kt$ReportView.Builder$var via: String? = null</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer$val metadata: Metadata</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer$val settings: SettingsProvider</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$// Do a lazy init because this table may never be used and it is large val ncesLookupTable = lazy { LookupTable.read("./metadata/tables/nces_id.csv") }</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val HD_TRUNCATION_LIMIT = 20</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val HL7_SPEC_VERSION: String = "2.5.1"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val MESSAGE_CODE = "ORU"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val MESSAGE_TRIGGER_EVENT = "R01"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val NCES_EXTENSION = "_NCES_"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val OBX_18_EQUIPMENT_UID_OID: String = "2.16.840.1.113883.3.3719"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val SOFTWARE_PRODUCT_NAME: String = "PRIME ReportStream"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Companion$const val SOFTWARE_VENDOR_ORGANIZATION: String = "Centers for Disease Control and Prevention"</ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Hl7Mapping$val errors: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Hl7Mapping$val mappedRows: Map&lt;String, List&lt;String>></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Hl7Mapping$val rows: List&lt;RowResult></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.Hl7Mapping$val warnings: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.RowResult$val errors: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.RowResult$val row: Map&lt;String, List&lt;String>></ID>
    <ID>UndocumentedPublicProperty:Hl7Serializer.kt$Hl7Serializer.RowResult$val warnings: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:HttpUtilities.kt$HttpUtilities.Companion$const val jsonMediaType = "application/json"</ID>
    <ID>UndocumentedPublicProperty:HttpUtilities.kt$HttpUtilities.Companion$const val oldApi = "/api/reports"</ID>
    <ID>UndocumentedPublicProperty:HttpUtilities.kt$HttpUtilities.Companion$const val tokenApi = "/api/token"</ID>
    <ID>UndocumentedPublicProperty:HttpUtilities.kt$HttpUtilities.Companion$const val watersApi = "/api/waters"</ID>
    <ID>UndocumentedPublicProperty:JtiCache.kt$JtiCache$val EXPIRATION_MINUTES: Long = 5</ID>
    <ID>UndocumentedPublicProperty:JurisdictionalFilters.kt$JurisdictionalFilters$// covid-19 default quality check consists of these filters // todo move this to a GLOBAL Setting in the settings table val defaultCovid19QualityCheck = listOf( // valid human and valid test "hasValidDataFor(" + "message_id," + "equipment_model_name," + "specimen_type," + "test_result," + "patient_last_name," + "patient_first_name," + "patient_dob" + ")", // has minimal valid location or other contact info (for contact tracing) "hasAtLeastOneOf(patient_street,patient_zip_code,patient_phone_number,patient_email)", // has valid date (for relevance/urgency) "hasAtLeastOneOf(order_test_date,specimen_collection_date_time,test_result_date)", // has at least one valid CLIA "isValidCLIA(testing_lab_clia,reporting_facility_clia)", // never send T (Training/Test) or D (Debug) data to the states. "doesNotMatch(processing_mode_code,T,D)", )</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val alg: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val crv: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val d: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val dp: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val dq: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val e: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val k: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val keyOps: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val kty: String</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val n: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val p: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val q: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val qi: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val use: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val x5c: List&lt;String>? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val x5t: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val x5u: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val x: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$val y: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$Jwk$var kid: String? = null</ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$JwkSet$val keys: List&lt;Jwk></ID>
    <ID>UndocumentedPublicProperty:Jwk.kt$JwkSet$val scope: String</ID>
    <ID>UndocumentedPublicProperty:LookupTable.kt$LookupTable$val rowCount: Int get() = if (table.isNotEmpty()) table.size - 1 else 0</ID>
    <ID>UndocumentedPublicProperty:LookupTableCommands.kt$LookupTableEndpointUtilities$val environment: Environment</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$ElementAndValue$val element: Element</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$ElementAndValue$val value: String</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val DEVICE_ID = "device_id"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val EQUIPMENT_MODEL_ID = "equipment_model_id"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val EQUIPMENT_MODEL_NAME = "equipment_model_name"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val LIVD_EQUIPMENT_UID = "Equipment UID"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val LIVD_MODEL = "Model"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val LIVD_TESTKIT_NAME_ID = "Testkit Name ID"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val LIVD_TEST_PERFORMED_CODE = "Test Performed LOINC Code"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val TEST_KIT_NAME_ID = "test_kit_name_id"</ID>
    <ID>UndocumentedPublicProperty:Mappers.kt$LIVDLookupMapper.Companion$const val TEST_PERFORMED_CODE = "test_performed_code"</ID>
    <ID>UndocumentedPublicProperty:MemoryJtiCache.kt$MemoryJtiCache$// implement the cache as a map from JTI string name to its expiration time var cache = mutableMapOf&lt;String, OffsetDateTime>()</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val component: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val equipmentUid: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val equipmentUidType: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val loincVersionId: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val manufacturer: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val method: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val model: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val property: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val publicationVersionId: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val scale: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val system: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testKitNameId: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testKitNameIdType: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testOrderedLoincCode: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testOrderedLoincLongName: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testPerformedLoincCode: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val testPerformedLoincLongName: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val time: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorAnalyteCode: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorAnalyteName: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorComment: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorReferenceId: String</ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorResultDescription: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:MetaDataFunction.kt$LivdData$val vendorSpecimenDescription: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata$/* * Schema */ val schemas: Collection&lt;Schema> get() = schemaStore.values</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata$/* file name templates */ val fileNameTemplates get() = fileNameTemplatesStore</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val fileNameTemplatesSubdirectory = "./file_name_templates"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val schemaExtension = ".schema"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val schemasSubdirectory = "schemas"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val tableExtension = ".csv"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val tableSubdirectory = "tables"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val valueSetExtension = ".valuesets"</ID>
    <ID>UndocumentedPublicProperty:Metadata.kt$Metadata.Companion$const val valuesetsSubdirectory = "valuesets"</ID>
    <ID>UndocumentedPublicProperty:OktaCommands.kt$OktaCommand.AccessTokenFile$val clientId: String</ID>
    <ID>UndocumentedPublicProperty:OktaCommands.kt$OktaCommand.AccessTokenFile$val expiresAt: LocalDateTime</ID>
    <ID>UndocumentedPublicProperty:OktaCommands.kt$OktaCommand.AccessTokenFile$val token: String</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$DeepOrganization$val receivers: List&lt;Receiver> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$DeepOrganization$val senders: List&lt;Sender> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$Organization$val countyName: String?</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$Organization$val description: String</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$Organization$val jurisdiction: Jurisdiction</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$Organization$val name: String</ID>
    <ID>UndocumentedPublicProperty:Organization.kt$Organization$val stateCode: String?</ID>
    <ID>UndocumentedPublicProperty:ProcessDataCommands.kt$InputSource.DirSource$val dirName: String</ID>
    <ID>UndocumentedPublicProperty:ProcessDataCommands.kt$InputSource.FakeSource$val count: Int</ID>
    <ID>UndocumentedPublicProperty:ProcessDataCommands.kt$InputSource.FileSource$val fileName: String</ID>
    <ID>UndocumentedPublicProperty:ProcessDataCommands.kt$InputSource.ListOfFilesSource$val commaSeparatedList: String</ID>
    <ID>UndocumentedPublicProperty:ProcessFunction.kt$const val azureFunctionName = "process"</ID>
    <ID>UndocumentedPublicProperty:ProcessFunction.kt$const val azureQueueName = "process"</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver$// adds a display name property that tries to show the external name, or the regular name if there isn't one @get:JsonIgnore val displayName: String get() = externalName ?: name</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver$@get:JsonIgnore val format: Report.Format get() = translation.format</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver$@get:JsonIgnore val fullName: String get() = "$organizationName$fullNameSeparator$name"</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver$@get:JsonIgnore val schemaName: String get() = translation.schemaName</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver$val reverseTheQualityFilter: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver.Companion$const val fullNameSeparator = "."</ID>
    <ID>UndocumentedPublicProperty:Receiver.kt$Receiver.Timing$val maxReportCount: Int = 500</ID>
    <ID>UndocumentedPublicProperty:RedoxSerializer.kt$RedoxSerializer$val metadata: Metadata</ID>
    <ID>UndocumentedPublicProperty:RedoxTransport.kt$RedoxTransport.SendResult$val itemId: String</ID>
    <ID>UndocumentedPublicProperty:RedoxTransport.kt$RedoxTransport.SendResult$val redoxId: Int? = null</ID>
    <ID>UndocumentedPublicProperty:RedoxTransport.kt$RedoxTransport.SendResult$val status: ResultStatus</ID>
    <ID>UndocumentedPublicProperty:Report.kt$// Basic size limitations on incoming reports // Experiments show 10k HL7 Items is ~41Meg. So allow 50Meg const val PAYLOAD_MAX_BYTES: Long = (50 * 1000 * 1000).toLong()</ID>
    <ID>UndocumentedPublicProperty:Report.kt$// constants used for parsing and processing a report message const val ROUTE_TO_SEPARATOR = ","</ID>
    <ID>UndocumentedPublicProperty:Report.kt$// the threshold for count of rows inside the report that we don't want // to shuffle at. If there are less than this number of rows in the table // then we just want to fake the data instead to prevent the leakage of PII const val SHUFFLE_THRESHOLD = 25</ID>
    <ID>UndocumentedPublicProperty:Report.kt$Report.Format$val ext: String</ID>
    <ID>UndocumentedPublicProperty:Report.kt$Report.Format$val isSingleItemFormat: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:Report.kt$Report.Format$val mimeType: String</ID>
    <ID>UndocumentedPublicProperty:Report.kt$const val DEFAULT_SEPARATOR = ":"</ID>
    <ID>UndocumentedPublicProperty:Report.kt$const val REPORT_MAX_ERRORS = 100</ID>
    <ID>UndocumentedPublicProperty:Report.kt$const val REPORT_MAX_ITEMS = 10000</ID>
    <ID>UndocumentedPublicProperty:Report.kt$const val REPORT_MAX_ITEM_COLUMNS = 2000</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val content: String = ""</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val defaults: Map&lt;String, String> = emptyMap()</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val errors: MutableList&lt;ResultDetail> = mutableListOf()</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val httpStatus: HttpStatus</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val options: Options = Options.None</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val routeTo: List&lt;String> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val sender: Sender? = null</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val valid: Boolean</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val verbose: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:ReportFunction.kt$ReportFunction.ValidatedRequest$val warnings: MutableList&lt;ResultDetail> = mutableListOf()</ID>
    <ID>UndocumentedPublicProperty:ReportStreamSecretFinder.kt$ReportStreamSecretFinder.Companion$const val TOKEN_SIGNING_SECRET_NAME = "TokenSigningSecret"</ID>
    <ID>UndocumentedPublicProperty:ResponseMessage.kt$ResponseMessage$val type: ResponseMsgType</ID>
    <ID>UndocumentedPublicProperty:ResultDetail.kt$ResultDetail$val responseMessage: ResponseMessage</ID>
    <ID>UndocumentedPublicProperty:ResultDetail.kt$ResultDetail$val rowNumber: Int get() = row + 1</ID>
    <ID>UndocumentedPublicProperty:RetryToken.kt$RetryToken$val items: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:RetryToken.kt$RetryToken$var retryCount: Int</ID>
    <ID>UndocumentedPublicProperty:RetryToken.kt$RetryToken.Companion$val allItems: RetryItems = listOf("*")</ID>
    <ID>UndocumentedPublicProperty:Schema.kt$Schema$val baseName: String get() = formBaseName(name)</ID>
    <ID>UndocumentedPublicProperty:Schema.kt$Schema$val basedOnRef: Schema? = null</ID>
    <ID>UndocumentedPublicProperty:Schema.kt$Schema$val csvFields: List&lt;Element.CsvField> get() = elements.flatMap { it.csvFields ?: emptyList() }</ID>
    <ID>UndocumentedPublicProperty:Schema.kt$Schema$val extendsRef: Schema? = null</ID>
    <ID>UndocumentedPublicProperty:SecretManagement.kt$SecretManagement$@Suppress("unused") val secretService: SecretService get() = secretServiceForStorageMethod()</ID>
    <ID>UndocumentedPublicProperty:SendFunction.kt$// index is retryCount, value is in minutes // We often send every 2 hours. Idea here is that the 4th retry occurs *before* the next round of sends, in 111 mins. val retryDuration = mapOf(1 to 1L, 2 to 5L, 3 to 30L, 4 to 75L, 5 to 120L)</ID>
    <ID>UndocumentedPublicProperty:SendFunction.kt$const val maxDurationValue = 120L</ID>
    <ID>UndocumentedPublicProperty:SendFunction.kt$const val maxRetryCount = 4</ID>
    <ID>UndocumentedPublicProperty:SendFunction.kt$const val send = "send"</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$@get:JsonIgnore val fullName: String get() = "$organizationName$fullNameSeparator$name"</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val customerStatus: CustomerStatus = CustomerStatus.INACTIVE</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val format: Format</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val keys: List&lt;JwkSet>? = null // used to track server-to-server auths for this Sender via public keys sets</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val name: String</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val organizationName: String</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val schemaName: String</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender$val topic: String</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender.Companion$const val fullNameSeparator = "."</ID>
    <ID>UndocumentedPublicProperty:Sender.kt$Sender.Format$val mimeType: String</ID>
    <ID>UndocumentedPublicProperty:SenderUtilsCommand.kt$AddPublicKey$val doIt by option( "--doit", help = "Save the modified Sender setting to the database (default is to just print the modified setting)" ).flag(default = false)</ID>
    <ID>UndocumentedPublicProperty:SenderUtilsCommand.kt$AddPublicKey$val publicKeyFilename by option( "--public-key", help = "Path to public key .pem file", metavar = "&lt;public-pem-key-file>" ) .required()</ID>
    <ID>UndocumentedPublicProperty:SenderUtilsCommand.kt$TokenUrl$val privateKeyFilename by option( "--private-key", help = "Path to private key .pem file", metavar = "&lt;private-keyfile>" ) .required()</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$GetMultipleSettings$val filter by option( "-f", "--filter", help = "filter the organizations, only returning those with names that start with &lt;filter>", metavar = "&lt;filter>" )</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SettingCommand$open val inStream: InputStream? = null</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SettingCommand$val jsonMapper = jacksonObjectMapper()</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SettingCommand$val yamlMapper: ObjectMapper = ObjectMapper(YAMLFactory()).registerModule(KotlinModule())</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$open val settingName: String = ""</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$val help: String</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$val name: String</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$val operation: Operation</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$val settingType: SettingType</ID>
    <ID>UndocumentedPublicProperty:SettingCommands.kt$SingleSettingCommandNoSettingName$val useJson by option( "--json", help = "Use the JSON format instead of YAML" ).flag(default = false)</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingAPI$val name: String</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingAPI$val organizationName: String?</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingAPI$var meta: SettingMetadata?</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingMetadata$val createdAt: OffsetDateTime</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingMetadata$val createdBy: String</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingMetadata$val version: Int</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingsFacade.Companion$// The SettingAccess is heavy-weight object (because it contains a Jackson Mapper) so reuse it when possible val common: SettingsFacade by lazy { SettingsFacade(metadata, DatabaseAccess()) }</ID>
    <ID>UndocumentedPublicProperty:SettingsFacade.kt$SettingsFacade.Companion$val metadata = Metadata.getInstance()</ID>
    <ID>UndocumentedPublicProperty:SettingsProvider.kt$SettingsProvider$val organizations: Collection&lt;Organization></ID>
    <ID>UndocumentedPublicProperty:SettingsProvider.kt$SettingsProvider$val receivers: Collection&lt;Receiver></ID>
    <ID>UndocumentedPublicProperty:SettingsProvider.kt$SettingsProvider$val senders: Collection&lt;Sender></ID>
    <ID>UndocumentedPublicProperty:Source.kt$ClientSource$val client: String</ID>
    <ID>UndocumentedPublicProperty:Source.kt$ClientSource$val name = "$organization.$client"</ID>
    <ID>UndocumentedPublicProperty:Source.kt$ClientSource$val organization: String</ID>
    <ID>UndocumentedPublicProperty:Source.kt$FileSource$val fileName: String</ID>
    <ID>UndocumentedPublicProperty:Source.kt$ReportSource$val action: String</ID>
    <ID>UndocumentedPublicProperty:Source.kt$ReportSource$val id: ReportId</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("access_token") val accessToken: String</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("expires_at_seconds") val expiresAtSeconds: Int</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("expires_in") val expiresIn: Int</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("scope") val scope: String</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("sub") val sub: String</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$AccessToken$@JsonProperty("token_type") val tokenType: String</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$FindSenderKeyInSettings$val scope: String</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$FindSenderKeyInSettings$var errorMsg: String? = null</ID>
    <ID>UndocumentedPublicProperty:TokenAuthentication.kt$TokenAuthentication$val jtiCache: JtiCache</ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val fromSchema: Schema</ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val missing: Set&lt;String></ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val toSchema: Schema</ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val useDefault: Map&lt;String, String></ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val useDirectly: Map&lt;String, String></ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val useMapper: Map&lt;String, Mapper></ID>
    <ID>UndocumentedPublicProperty:Translator.kt$Translator.Mapping$val useValueSet: Map&lt;String, String></ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$// Schemas used const val HL7_SCHEMA = "covid-19"</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val cliaForOutOfStateTesting: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val cliaForSender: Map&lt;String, String>? = emptyMap()</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val convertTimestampToDateTime: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val defaultAoeToUnknown: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val messageProfileId: String?</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val phoneNumberFormatting: PhoneNumberFormatting = PhoneNumberFormatting.STANDARD</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val processingModeCode: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val receivingApplicationName: String?</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val receivingApplicationOID: String?</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val receivingFacilityName: String?</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val receivingFacilityOID: String?</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val replaceDiiWithOid: Boolean? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val replaceValue: Map&lt;String, String>? = emptyMap()</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val reportingFacilityId: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val reportingFacilityIdType: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val reportingFacilityName: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val suppressAoe: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val suppressHl7Fields: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val suppressQstForAoe: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val truncateHDNamespaceIds: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val useBatchHeaders: Boolean = true</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val useBlankInsteadOfUnknown: String? = null</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val useOrderingFacilityName: OrderingFacilityName = OrderingFacilityName.STANDARD</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val usePid14ForPatientEmail: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$Hl7Configuration$val useTestProcessingMode: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$RedoxConfiguration$val destinationId: String</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$RedoxConfiguration$val destinationName: String</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$RedoxConfiguration$val sourceId: String</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$RedoxConfiguration$val sourceName: String</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$RedoxConfiguration$val useTestProcessingMode: Boolean = false</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$TranslatorConfiguration$val type: String</ID>
    <ID>UndocumentedPublicProperty:TranslatorConfiguration.kt$const val REDOX_SCHEMA = "covid-19-redox"</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val contentDescription: String = "SARS-CoV-2 Electronic Lab Results"</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val mimeType: String = "application/hl7-v2"</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val receiverId: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val receiverUrl: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val senderEmail: String = "reportstream@cdc.gov"</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$AS2TransportType$val senderId: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$BlobStoreTransportType$val containerName: String // eg, hhsprotect</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$BlobStoreTransportType$val storageName: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$EmailTransportType$val addresses: List&lt;String></ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$EmailTransportType$val from: String = "qtv1@cdc.gov" // TODO: default to a better choice</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val binaryTransfer: Boolean = true</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val host: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val password: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val port: Int</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val protocol: FtpsProtocol = FtpsProtocol.SSL</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$FTPSTransportType$val username: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$NullTransportType$val dummy: String? = null</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$RedoxTransportType$val apiKey: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$RedoxTransportType$val baseUrl: String?</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$SFTPTransportType$val credentialName: String? = null</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$SFTPTransportType$val filePath: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$SFTPTransportType$val host: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$SFTPTransportType$val port: String</ID>
    <ID>UndocumentedPublicProperty:TransportType.kt$TransportType$val type: String</ID>
    <ID>UndocumentedPublicProperty:USTimeZone.kt$USTimeZone$val zoneId: String</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val name: String</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val reference: String? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val referenceUrl: String? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val system: SetSystem</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val systemCode get() = when (system) { SetSystem.HL7 -> name.uppercase() SetSystem.SNOMED_CT -> "SCT" SetSystem.LOINC -> "LN" SetSystem.UCUM -> "UCUM" SetSystem.LOCAL -> "LOCAL" SetSystem.FHIR -> "FHIR" SetSystem.NULLFL -> "NULLFL" }</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val values: List&lt;Value> = emptyList()</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet$val version: String? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet.Value$val code: String</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet.Value$val display: String? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet.Value$val replaces: String? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet.Value$val system: SetSystem? = null</ID>
    <ID>UndocumentedPublicProperty:ValueSet.kt$ValueSet.Value$val version: String? = null</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val as2Transport: AS2Transport = AS2Transport()</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val blob: BlobAccess = BlobAccess(csvSerializer, hl7Serializer, redoxSerializer)</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val blobStoreTransport: BlobStoreTransport = BlobStoreTransport(this)</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val csvSerializer: CsvSerializer = WorkflowEngine.csvSerializer</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val db: DatabaseAccess = databaseAccess</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val ftpsTransport: FTPSTransport = FTPSTransport()</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val hl7Serializer: Hl7Serializer = WorkflowEngine.hl7Serializer</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val metadata: Metadata = WorkflowEngine.metadata</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val queue: QueueAccess = QueueAccess</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val redoxSerializer: RedoxSerializer = WorkflowEngine.redoxSerializer</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val redoxTransport: RedoxTransport = RedoxTransport()</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val settings: SettingsProvider = WorkflowEngine.settings</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val sftpTransport: SftpTransport = SftpTransport()</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine$val translator: Translator = Translator(metadata, settings)</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Companion$val databaseAccess: DatabaseAccess by lazy { DatabaseAccess() }</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Companion$val settings: SettingsProvider by lazy { val baseDir = System.getenv("AzureWebJobsScriptRoot") ?: "." val settingsEnabled: String? = System.getenv("FEATURE_FLAG_SETTINGS_ENABLED") if (settingsEnabled == null || settingsEnabled.equals("true", ignoreCase = true)) { SettingsFacade(metadata, databaseAccess) } else { val ext = "-${Environment.get().toString().lowercase()}" FileSettings("$baseDir/settings", orgExt = ext) } }</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val content: ByteArray?</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val itemLineages: List&lt;ItemLineage>?</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val organization: Organization?</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val receiver: Receiver?</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val reportFile: ReportFile</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val schema: Schema?</ID>
    <ID>UndocumentedPublicProperty:WorkflowEngine.kt$WorkflowEngine.Header$val task: Task</ID>
    <ID>UnnecessaryAbstractClass:TransportType.kt$TransportType</ID>
    <ID>UnusedPrivateClass:RedoxSerializer.kt$RedoxSerializer$JsonGroupType</ID>
    <ID>UnusedPrivateMember:ActionHistory.kt$ActionHistory$private fun insertItemLineage(itemLineage: ItemLineage, txn: Configuration)</ID>
    <ID>UnusedPrivateMember:FakeReport.kt$FakeReport.Companion$i</ID>
    <ID>UnusedPrivateMember:FakeReport.kt$FakeReport.Companion$private fun randomChoices(vararg choices: String): List&lt;String></ID>
    <ID>UnusedPrivateMember:FileNameTemplateTests.kt$FileNameTemplateTests$@BeforeTest private fun setFormattedDate()</ID>
    <ID>UnusedPrivateMember:Hl7Serializer.kt$Hl7Serializer$private fun formatEI(eiFields: Element.EIFields, separator: String = "^"): String</ID>
    <ID>UnusedPrivateMember:MetaDataFunction.kt$MetaDataFunction$context: ExecutionContext</ID>
    <ID>UnusedPrivateMember:ProcessDataCommands.kt$ProcessData$// NOTE: This exists to support not-yet-implemented functionality. private fun postHttp(address: String, block: (stream: OutputStream) -> Unit)</ID>
    <ID>UnusedPrivateMember:RedoxTransport.kt$RedoxTransport$private val redoxMessageId = "messageId"</ID>
    <ID>UnusedPrivateMember:SettingsFunctions.kt$BaseFunction$private val invalidClaim = HttpUtilities.errorJson("Invalid Authorization Header")</ID>
    <ID>UnusedPrivateMember:SettingsFunctions.kt$BaseFunction$private val missingAuthorizationHeader = HttpUtilities.errorJson("Missing Authorization Header")</ID>
    <ID>UnusedPrivateMember:SettingsUtilities.kt$private const val apiPath = "/api/settings"</ID>
    <ID>UnusedPrivateMember:Simulator.kt$Simulator$i</ID>
    <ID>UnusedPrivateMember:TestReportStream.kt$SantaClaus$ private fun waitWithConditionalRetry( retries: Int, block: () -> Boolean, callback: (succeed: Boolean, retryCount: Int) -> Unit ): Boolean</ID>
    <ID>UtilityClassWithPublicConstructor:CredentialManagement.kt$CredentialHelper</ID>
    <ID>UtilityClassWithPublicConstructor:FileUtilities.kt$FileUtilities</ID>
    <ID>UtilityClassWithPublicConstructor:HttpUtilities.kt$HttpUtilities</ID>
    <ID>UtilityClassWithPublicConstructor:Scope.kt$Scope</ID>
    <ID>UtilityClassWithPublicConstructor:SecretManagement.kt$SecretHelper</ID>
    <ID>UtilityClassWithPublicConstructor:SenderUtils.kt$SenderUtils</ID>
    <ID>UtilityClassWithPublicConstructor:SettingsUtilities.kt$SettingsUtilities</ID>
    <ID>VariableNaming:HistoryFunctions.kt$BaseHistoryFunction$val DAYS_TO_SHOW = 30L</ID>
    <ID>VariableNaming:JtiCache.kt$JtiCache$val EXPIRATION_MINUTES: Long = 5</ID>
    <ID>VariableNaming:TokenAuthentication.kt$TokenAuthentication$private val EXPIRATION_SECONDS = 300</ID>
    <ID>VariableNaming:TokenAuthentication.kt$TokenAuthentication$private val MAX_CLOCK_SKEW_SECONDS: Long = 60</ID>
  </CurrentIssues>
</SmellBaseline>
