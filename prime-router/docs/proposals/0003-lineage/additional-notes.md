## Additional notes as the code was developed

### ACTIONs

The ACTION table is strictly a record of an action that has already occurred.  It is meant to be immutable - no updates. 

My current plan is that we'll have separate table, NEXT_ACTION or maybe TODO, that will take the role currently played by the TASK table.   Then we can simply leave the TASK table in the database, not used, so we have that history.   If needed, that history can be migrated to the new tables.

You could argue that ACTION should be renamed ACTION_HIST.  

### REPORT_FILE

Every report in the database must be generated by an action.

The initial `receive` action does quite a lot:  it generates both the incoming file, and the transformed reports for each future receiver as well.

I considered naming this table REPORT_HIST instead of REPORT_FILE, and making it immutable.  I can think of a couple reasons not to do this:
1. Bad data.   If the system generates erroneous data, you need a way to mark that data as bad.
2. The WIPE action - I feel like if you wipe a report from the system, the REPORT_FILE table should be updated to reflect that the data no longer exists.
One option would be to implement triggers that prevent updates except for a status field.  Note:  the report_file table currently has no status field.

### REPORT_LINEAGE

This simple parent/child table should also be immutable.

### ITEM Tracking

#### Ordering Assumption####

To ensure that items can be uniquely tracked, we make the following key assumption:

We assume that within any one report, the index ordering (eg, 0, 1, 2,...) and number of Items is fixed. That is, we can write a Report to a blob store, and read it back into memory later, and be certain that the order of the Items and the number of Items has not changed.   This simple assumption means our code can guarantee unique Item lineage tracking, because (item_index, report_id) is now a system-wide unique key for each Item.   When we read data from the blob store, we now have a simple way to match Items in the data blob to corresponding items tracked in our lineage database tables.

Note that other options are not as good:
- use the sending customer's trackingElement (bad: might not be unique, and doubly bad because it requires the send step to parse hl7, csv), or
- attaching our own additional unique id into the blob data (bad: the downstream receiving customer doesn't want our ids in their data)

#### Numbering ####

The index columns (parent_index, child_index) in the item_lineage table are zero-based.   So if you are looking at a CSV file with a header row, then row 2 has index = 0 in item_lineage, row 3 has index = 1 in item_lineage, and so on.


### Notes on ITEM tracking in each of the main azure functions:

**All or nothing assertion**: Throughtout item_lineage tracking, the code asserts the following:  either no lineage is tracked (for example, for older data prior to item_lineage implementation), or lineage is tracked completely for every item.  No partial/incomplete item_lineage - that's an error that causes an exception.   This means that our future reporting/auditing code doesn't need to worry about weirdly incomplete data.  If its incomplete, that's a bug that we need to fix asap.

**ReportFunction and BatchFunction**:  As they do transforms on the data, both of these functions have access to both parent and child Report.kt objects.  These functions uses that Report.kt data to create item_lineage info.  Notes that Reports can be transmogrified in memory in all kinds of ways in these steps, through split(), merge(), copy(), and filter().   Item_lineage is carefully preserved through all such transformations.   If in the future we add new clever data transform code to Report.kt, we will need to make sure item_lineage is preserved during that transform.

**SendFunction and DownloadFunction**:  These functions never create Report objects (which is good - we should be messing with the data as little as possible).  In these cases, item_lineage data for the parent report is read from the database, and that's used as the basis for creating the parent->child item_lineage.   Currently, these functions are also simpler, in that there's a 1:1 mapping from parent to child rows in these functions.

**Splitting and merging individual items**:  While reports break apart and merge, etc, items do not.  That is, as of this writing, we have no use cases where *rows* split or merge.  While the database is designed to handle these situations, the code has not been tested for this, and I suspect there will be issues.

**Main issue remaining**:  When a Report is read into BatchFunction whose schema has no trackingElement defined in the .schema, we lose the tracking_id column in the item_lineage table.  This is an artifact of how lineage tracking works in BatchFunction, where lineage is created in-memory based on data in the Report.kt objects.   If the parent report in the lineage has no trackingElement defined, then of course we can't fill in the item_lineage.tracking_id column.  (Currently most/all hl7 schemas are affected by this, as they do not have trackingElements.)  A possible fix is to read in the parent's item_lineage from the database table.  However, that ID often does not exist in the child data - its not clear what the value is of tracking an ID that is not even in the data.  Further complexity with trackingElements will arise if we begin splitting/merging Items (see comment above).


