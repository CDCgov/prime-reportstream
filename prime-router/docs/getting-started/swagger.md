# Swagger UI

Swagger UI is a tool that allows you to visually interact with ReportStream APIs that have been defined using the OpenAPI
Specification (OAS). It provides a user-friendly interface that makes it easier to understand and explore capabilities of
the API without requiring external tools such as curl or Postman.

This directory contains all open api spec resources:

- ./swagger-ui: swagger ui artifacts (with customization - see custom and maintain notes below)
- ./generated: auto generated api spec(s) from annotated kotlin source files

## Purpose

Swagger enables:

1. **Documentation:** displays documentation generated from code in a terse yet approachable format that serves as great
   reference material.

2. **API Visualization:** provides a structured interface that displays API endpoints, request parameters, response
   structures, and example requests and responses in a structured, readable, and navigable format.

3. **API Testing:** facilitates direct interaction with the API. You can input parameters, make requests, and
   see the responses right in your browser with no external tools.

## Usage
With an API selected the UI will display a list of endpoints. Each endpoint can be expanded to display the
usage, parameters, and expected output; as well as an interface to make an API call.

### Accessing the Swagger UI Interface

The interface consists of static web assets that are compiled from annotations in our back-end code and served similarly
to our front-end web application. The UI can only be accessed locally in the azure storage instance once compiled. To
access it, run the prime-router stack, then navigate to the URL below:

**Local** http://127.0.0.1:10000/devstoreaccount1/apidocs/index.html

Please note you may encounter cross-origin restrictions when trying to access one environment from outside its URL.

### Authentication

Swagger has built-in support for authentication; it will map user-provided credentials into the appropriate headers and
even handle obtaining and refreshing a bearer token using OAuth.

Regardless of chosen authentication method, the steps are similar:
Near the top-right of the interface you'll find an `Authorize` button which will bring up a menu with the authentication
methods available (described below). Each option will require some inputs.

#### Okta

Okta provides an implementation of OAuth2 for authentication. It utilizes a `client ID` and a `client secret`, generated
by ReportStream and provided to the client, that is encoded as a JSON Web-Token. This token is submitted to the server
in order to request a bearer token. This token will then be used to authenticate further requests. It expires after 5
minutes so it must be periodically refreshed using a separate API call.

##### Client Instructions
Starting from the Okta section in the `Authorize` menu
1. Provide the `client ID` / `secret`, select the scope, and click the Authorize button
2. You will be redirected to Okta for 2-factor authentication (2FA)
3. You will be redirected back to the Swagger UI; you may now close the Authorize menu and issue requests

##### Okta Configuration

1. Login to OKTA as an administrator and click the "Admin" button in the top-right
2. In the left pane, navigate Applications -> applications
3. In the resulting right pane, select the instance to be configured (e.g. `Simple Report (localdev)`)
4. Viewing the details of the instance, you will see a `client_id` and `client_secret` (be sure to mask these values)
5. Under General Settings, ensure the "Authorization Code" flow is checked
6. Under Login, ensure this value appears in the sign-in redirect URI list:  
   `http://127.0.0.1:10000/devstoreaccount1/apidocs/oauth2-redirect.html`
7. Ensure the application instance is associated with your OKTA account. Select assignment at the top of the page and 
   ensure your username is selected. 
8. You need to associate "Simple Report (localdev)" with you - your OKTA account (your email/password/MFA)
   To do so, click the assignment on top of the page and you will see all the users : Joe Smith, Jane Doe etc., select your user name, and you will be tied to the app - Simple Report (localdev)

#### Server-to-server

###### Background
This method is based on best practices outlined in the [SMART on FHIR Implementation Guide](http://hl7.org/fhir/uv/bulkdata/authorization/index.html).
Similar to Okta above, this method follows the principles of OAuth2. A `client secret`, `client ID`, and `scope` is
encoded as a JSON Web-Token and sent to the server in a header value via the `/api/token` endpoint. The server responds
with a bearer token the client can use to authenticate and authorize further requests. This token will expire every 5
minutes and must be refreshed with a separate API call.

###### Generating a client key
Unlike Okta, the client secret must be generated by the client and provided to ReportStream. Instructions and a related helper python
script is provided [in this repo](/prime-router/examples/generate-jwt-python/README.md). See the README in that directory for instructions,
summarized here:
```bash
openssl genrsa -out my-rsa-private-key 2048
openssl rsa -in my-rsa-private-key -outform PEM -pubout -out my-rsa-public-key.pem
```

###### Encoding credentials as a JWT to be sent to the server
The initial JWT sent to the server must be created outside of the swagger environment. An example using a python script
is provided [in this repo](/examples/generate-jwt-python). See the README in that directory for instructions, summarized
here:
1. Install python dependencies for generating JWT
2. Set variables on lines 28-30 in the script (`my_client_id`, `my_kid`, and `my_rsa_keypair_file`)
3. Run the script! The penultimate curl contains the JWT used to retrieve a bearer token. The final curl contains an
   example using that bearer token.

## Developer Notes

The openapi spec for ReportStream is generated from annotations in the code. This facilitates accurate, timely
updates and ameliorates an otherwise lengthy, manual, repetitive, and error-prone process.

### OpenAPI Specification Maintenance
Since the swagger files are generated from annotations in the code, any changes must be made to the annotations
(or in the config of the underlying library) rather than the swagger YAML files themselves. These annotations use openapi
classes and data structures to decorate functions with any metadata to document functions.

<details>
  <summary>Annotation Example (From `ApiKeysFunction.kt` function `getApiKeysV1` for retrieval of api keys): </summary>

```kotlin
    @Operation(
        summary = "Retrieve API keys for the organization (v1), return API keys when successful",
        description = OPERATION_GET_KEYS_DESC,
        tags = [KEY_MGMT_TAG],
        parameters = [
            Parameter(
                name = PARAM_NAME_ORGNAME,
                required = true,
                description = PARAM_DESC_ORGNAME_GET,
            )
        ],
        responses = [
            ApiResponse(
                responseCode = HTTP_200_OK,
                description = HTTP_200_GET_MSG,
                content = [
                    Content(
                        mediaType = "application/json",
                        schema = Schema(implementation = ApiKeysResponse::class),
                        examples = [
                            ExampleObject(
                                name = "Example response for API key retrieval",
                                summary = "Example response when key retrieved successfully",
                                value = EX_GET_APIKEYS_RESP
                            ),
                        ]
                    )
                ]
            ),
            ApiResponse(
                responseCode = HTTP_404_NOT_FOUND,
                description = HTTP_404_ERR_MSG,
                content = [
                    Content(
                        mediaType = "application/json",
                        schema = Schema(implementation = String::class)
                    )
                ]
            ),
            ApiResponse(
                responseCode = HTTP_400_BAD_REQ,
                description = HTTP_400_ERR_MSG,
                content = [
                    Content(
                        mediaType = "application/json",
                        schema = Schema(implementation = String::class)
                    )
                ]
            )
        ]
    )
    @GET
    @Path("v1/settings/organizations/{organizationName}/public-keys")
    fun getV1( . . . 
```
</details>

For more examples of such annotations, search for `@Operation` in the codebase.